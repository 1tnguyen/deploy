<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Add a New Circuit Synthesis Strategy - AIDE-QC</title><meta name=description content="Advancing Integrated Development Environments for Quantum Computing"><meta name=generator content="Hugo 0.76.5"><link href=https://aide-qc.github.io/deployindex.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://aide-qc.github.io/deploy/developers/implement_circuit_synthesis/><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://aide-qc.github.io/deploy/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://aide-qc.github.io/deploy/aide_qc_logo_v3.png width=40px align=absmiddle>
AIDE-QC</div></h1><p class=description>Advancing Integrated Development Environments for Quantum Computing</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://aideqc.slack.com>AIDE-QC Slack</a></li><li class=child><a href=https://xacc-dev.slack.com>XACC/QCOR Slack</a></li></ul></li><li class=parent><a href=https://github.com/aide-qc>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://ornl-qci.github.io/qcor-api-docs/>QCOR Doxygen</a></li><li class=child><a href=https://ornl-qci.github.io/xacc-api-docs/>XACC Doxygen</a></li><li class=child><a href=https://github.com/aide-qc/qcor>QCOR</a></li><li class=child><a href=https://github.com/aide-qc/xacc>XACC</a></li></ul></li><li><a href=https://github.com/aide-qc/aide-qc/issues>Bugs</a></li><li><a href=http://aide-qc.org>Project Page</a></li></ul></nav></div><div class=content-container><main><h1>Add a New Circuit Synthesis Strategy</h1><p>Here we describe how developers can extend the AIDE-QC stack with support for a new circuit synthesis strategy.
We define circuit synthesis at the black-box level: a unitary matrix goes in and a list of one and two
qubit gates come out.</p><h2 id=a-idbackgrounda-background><a id=background></a>Background&nbsp;<a class=headline-hash href=#a-idbackgrounda-background>¶</a></h2><p>To understand the class architecture for circuit synthesis strategies, it is important to understand the
internal intermediate representation that AIDE-QC leverages for compiled quantum kernels. AIDE-QC builds upon
the XACC intermediate representation, which exposes <code>Instruction</code> and <code>CompositeInstruction</code> abstract classes that
are intended for subclassing for concrete instruction types and collections of concrete instructions. The IR model
puts forward a collection of default <code>Instruction</code> sub-types for common quantum gates, and a <code>Circuit</code> sub-class for
<code>CompositeInstruction</code> that models a quantum circuit (collection of gates). Pertinent methods on the <code>Circuit</code> (inherited from
<code>CompositeInstruction</code>) consist of <code>addInstruction</code>, <code>replaceInstruction</code>, <code>insertInstruction</code>, <code>getInstructions</code>, and <code>expand</code>. These are
all pretty self-explanatory, but <code>expand</code> requires a bit of a description of its functionality, as it is critical
to circuit synthesis in the AIDE-QC stack. This method has signature <code>bool expand(options : HeterogeneousMap)</code>.
The <code>options</code> <code>HeterogeneousMap</code> is a data structure that maps <code>string</code> keys to values of any type. The goal of
<code>expand</code> is to take as input this options map, and use the information contained within it to construct
<code>this</code> (or <code>self</code> in the Python jargon) <code>CompositeInstruction</code>, return <code>true</code> on success and <code>false</code> on an error.</p><p>Therefore, to inject a new circuit synthesis strategy into the stack, one simply implements a new <code>Circuit</code> sub-type with
a valid and strategy-specific implementation of <code>expand</code>. Of note - the compiler stack will always pass the <code>unitary</code>
key with corresponding <code>Eigen::MatrixXcd</code> value for circuit synthesis strategies coming from the use of <code>decompose {}(...)</code> in
C++ or <code>with decompose(...) as mat_var:</code> in Python.</p><h2 id=a-idcreate-syntha-create-custom-circuit-synthesis-plugin><a id=create-synth></a>Create Custom Circuit Synthesis Plugin&nbsp;<a class=headline-hash href=#a-idcreate-syntha-create-custom-circuit-synthesis-plugin>¶</a></h2><p>We start by creating a directory and the necessary files for the creation of a new circuit synthesis plugin</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>mkdir my_circ_synth <span class=o>&amp;&amp;</span> <span class=nb>cd</span> my_circ_synth
touch CMakeLists.txt manifest.json my_circ_synth.<span class=o>{</span>hpp,cpp<span class=o>}</span>
</code></pre></div><p>The plugin must define a <code>manifest.json</code> file to encode information about the plugin name and description. We populate the file with the following</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>{</span>
  <span class=nt>&#34;bundle.symbolic_name&#34;</span> <span class=p>:</span> <span class=s2>&#34;my_circ_synth&#34;</span><span class=p>,</span>
  <span class=nt>&#34;bundle.activator&#34;</span> <span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
  <span class=nt>&#34;bundle.name&#34;</span> <span class=p>:</span> <span class=s2>&#34;My Cool Circuit Synthesis Method&#34;</span><span class=p>,</span>
  <span class=nt>&#34;bundle.description&#34;</span> <span class=p>:</span> <span class=s2>&#34;Cool Description Here.&#34;</span>
<span class=p>}</span>
</code></pre></div><p>Now we populate the <code>CMakeLists.txt</code> file with typical <code>CMake</code> boilerplate project calls, plus additional code to correctly build our plugin and install to the appropriate plugin folder location:</p><div class=highlight><pre class=chroma><code class=language-cmake data-lang=cmake><span class=c># Boilerplate CMake calls to setup the project
</span><span class=c></span><span class=nb>cmake_minimum_required</span><span class=p>(</span><span class=s>VERSION</span> <span class=s>3.12</span> <span class=s>FATAL_ERROR</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>project</span><span class=p>(</span><span class=s>my_circ_synth</span> <span class=s>VERSION</span> <span class=s>1.0.0</span> <span class=s>LANGUAGES</span> <span class=s>CXX</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_STANDARD_REQUIRED</span> <span class=s>ON</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_CXX_STANDARD</span> <span class=s>17</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_EXPORT_COMPILE_COMMANDS</span> <span class=s>TRUE</span><span class=p>)</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=c># Find XACC, provides underlying plugin system
</span><span class=c></span><span class=nb>find_package</span><span class=p>(</span><span class=s>XACC</span> <span class=s>REQUIRED</span><span class=p>)</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>LIBRARY_NAME</span> <span class=s>my-circ-synth</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>file</span><span class=p>(</span><span class=s>GLOB</span> <span class=s>SRC</span> <span class=s>my_circ_synth.cpp</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>usfunctiongetresourcesource</span><span class=p>(</span><span class=s>TARGET</span> <span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span> <span class=s>OUT</span> <span class=s>SRC</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>usfunctiongeneratebundleinit</span><span class=p>(</span><span class=s>TARGET</span> <span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span> <span class=s>OUT</span> <span class=s>SRC</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>add_library</span><span class=p>(</span><span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span> <span class=s>SHARED</span> <span class=o>${</span><span class=nv>SRC</span><span class=o>}</span><span class=p>)</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=nb>target_include_directories</span><span class=p>(</span><span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span> <span class=s>PUBLIC</span> <span class=s>.</span> 
                                    <span class=s>LBFGSpp/include</span> 
                                    <span class=o>${</span><span class=nv>XACC_ROOT</span><span class=o>}</span><span class=s>/include/eigen</span><span class=p>)</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=c># _bundle_name must be == manifest.json bundle.symbolic_name !!!
</span><span class=c></span><span class=nb>set</span><span class=p>(</span><span class=s>_bundle_name</span> <span class=s>my_circ_synth</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>set_target_properties</span><span class=p>(</span><span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span>
                      <span class=s>PROPERTIES</span> <span class=s>COMPILE_DEFINITIONS</span>
                                 <span class=s>US_BUNDLE_NAME=</span><span class=o>${</span><span class=nv>_bundle_name</span><span class=o>}</span>
                                 <span class=s>US_BUNDLE_NAME</span> <span class=o>${</span><span class=nv>_bundle_name</span><span class=o>}</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>usfunctionembedresources</span><span class=p>(</span><span class=s>TARGET</span> <span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span> 
                         <span class=s>WORKING_DIRECTORY</span> <span class=o>${</span><span class=nv>CMAKE_CURRENT_SOURCE_DIR</span><span class=o>}</span>
                         <span class=s>FILES</span> <span class=s>manifest.json</span><span class=p>)</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=c># Link library with XACC
</span><span class=c></span><span class=nb>target_link_libraries</span><span class=p>(</span><span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span> <span class=s>PUBLIC</span> <span class=s>xacc::xacc</span><span class=p>)</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=c># Configure RPATH
</span><span class=c></span><span class=nb>if</span><span class=p>(</span><span class=s>APPLE</span><span class=p>)</span><span class=err>
</span><span class=err></span>  <span class=nb>set_target_properties</span><span class=p>(</span><span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span> <span class=s>PROPERTIES</span> <span class=s>INSTALL_RPATH</span> 
                            <span class=s2>&#34;${XACC_ROOT}/lib&#34;</span><span class=p>)</span><span class=err>
</span><span class=err></span>  <span class=nb>set_target_properties</span><span class=p>(</span><span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span> <span class=s>PROPERTIES</span> <span class=s>LINK_FLAGS</span> 
                            <span class=s2>&#34;-undefined dynamic_lookup&#34;</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>else</span><span class=p>()</span><span class=err>
</span><span class=err></span>  <span class=nb>set_target_properties</span><span class=p>(</span><span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span> <span class=s>PROPERTIES</span> <span class=s>INSTALL_RPATH</span> 
                        <span class=s2>&#34;${XACC_ROOT}/lib&#34;</span><span class=p>)</span><span class=err>
</span><span class=err></span>  <span class=nb>set_target_properties</span><span class=p>(</span><span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span> <span class=s>PROPERTIES</span> <span class=s>LINK_FLAGS</span> <span class=s2>&#34;-shared&#34;</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>endif</span><span class=p>()</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=c># Install to Plugins directory
</span><span class=c></span><span class=nb>install</span><span class=p>(</span><span class=s>TARGETS</span> <span class=o>${</span><span class=nv>LIBRARY_NAME</span><span class=o>}</span> <span class=s>DESTINATION</span> <span class=o>${</span><span class=nv>XACC_ROOT</span><span class=o>}</span><span class=s>/plugins</span><span class=p>)</span><span class=err>
</span></code></pre></div><p>The above CMake code is pretty much ubiquitous across all XACC plugin builds. The first crucial part is <code>find_package(XACC)</code> which can be configured or customized with the <code>cmake .. -DXACC_DIR=/path/to/xacc</code> flag. Next we create a shared library containing the compiled <code>my_circ_synth</code> code, and configure it as a plugin with appropriate <code>usfunction*</code> calls (from the underlying <code>CppMicroServices</code> infrastructure). We link the library to the <code>xacc::xacc</code> target, configure the <code>RPATH</code> such that it can link to the install <code>lib/</code> directory, and install to the plugin storage directory.</p><p>Next, we populate the <code>my_circ_synth.{hpp,cpp}</code> files with the required skeleton code</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#pragma once
</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&#34;Circuit.hpp&#34;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&#34;IRProvider.hpp&#34;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;Eigen/Dense&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=c1>// Feel free to use your own namespaces
</span><span class=c1></span><span class=k>namespace</span> <span class=n>xacc</span> <span class=p>{</span>
<span class=k>namespace</span> <span class=n>circuits</span> <span class=p>{</span>
<span class=k>class</span> <span class=nc>MyCircSynth</span> <span class=o>:</span> <span class=k>public</span> <span class=n>xacc</span><span class=o>::</span><span class=n>quantum</span><span class=o>::</span><span class=n>Circuit</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=n>MyCircSynth</span><span class=p>()</span> <span class=o>:</span> <span class=n>Circuit</span><span class=p>(</span><span class=s>&#34;my_custom_synth&#34;</span><span class=p>)</span> <span class=p>{}</span>
  <span class=kt>bool</span> <span class=nf>expand</span><span class=p>(</span><span class=k>const</span> <span class=n>xacc</span><span class=o>::</span><span class=n>HeterogeneousMap</span> <span class=o>&amp;</span><span class=n>runtimeOptions</span><span class=p>)</span> <span class=k>override</span><span class=p>;</span>
  <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>requiredKeys</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span>
  <span class=o>~</span><span class=n>MyCircSynth</span><span class=p>();</span>
  <span class=n>DEFINE_CLONE</span><span class=p>(</span><span class=n>PyQsearch</span><span class=p>);</span>
<span class=p>};</span>
<span class=p>}</span> <span class=c1>// namespace circuits
</span><span class=c1></span><span class=p>}</span> <span class=c1>// namespace xacc
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&#34;my_circ_synth.hpp&#34;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&#34;xacc.hpp&#34;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&#34;xacc_plugin.hpp&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=k>namespace</span> <span class=n>xacc</span> <span class=p>{</span>

<span class=k>namespace</span> <span class=n>circuits</span> <span class=p>{</span>
<span class=kt>bool</span> <span class=n>MyCircSynth</span><span class=o>::</span><span class=n>expand</span><span class=p>(</span><span class=k>const</span> <span class=n>xacc</span><span class=o>::</span><span class=n>HeterogeneousMap</span> <span class=o>&amp;</span><span class=n>parameters</span><span class=p>)</span> <span class=p>{</span>

  <span class=n>Eigen</span><span class=o>::</span><span class=n>MatrixXcd</span> <span class=n>unitary</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>parameters</span><span class=p>.</span><span class=n>keyExists</span><span class=o>&lt;</span><span class=n>Eigen</span><span class=o>::</span><span class=n>MatrixXcd</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;unitary&#34;</span><span class=p>))</span> <span class=p>{</span>
    <span class=n>unitary</span> <span class=o>=</span> <span class=n>parameters</span><span class=p>.</span><span class=n>get</span><span class=o>&lt;</span><span class=n>Eigen</span><span class=o>::</span><span class=n>MatrixXcd</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;unitary&#34;</span><span class=p>);</span>
  <span class=p>}</span>
  
  <span class=c1>// This is where you write your circuit synthesis code!!!
</span><span class=c1></span>  <span class=c1>// Goal here is to take the unitary matrix and output some 
</span><span class=c1></span>  <span class=c1>// kind of qasm-like representation. Ultimately, the output 
</span><span class=c1></span>  <span class=c1>// needs to be mapped to XACC IR Instructions and added to this 
</span><span class=c1></span>  <span class=c1>// Circuit with this-&gt;addInstruction(...). 
</span><span class=c1></span>
  <span class=c1>// For demonstration purposes, 
</span><span class=c1></span>  <span class=c1>// lets assume that you have some way to convert this unitary to 
</span><span class=c1></span>  <span class=c1>// a OpenQasm string. We&#39;ll use the XACC staq Compiler to map this 
</span><span class=c1></span>  <span class=c1>// OpenQasm string to XACC IR and addInstruction on this Circuit
</span><span class=c1></span>
  <span class=k>auto</span> <span class=n>oqasm_src</span> <span class=o>=</span> <span class=n>my_custom_way_to_get_openqasm</span><span class=p>(...);</span>

  <span class=c1>// Get the Staq Compiler and create XACC IR from oqasm_src
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>staq</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>::</span><span class=n>getCompiler</span><span class=p>(</span><span class=s>&#34;staq&#34;</span><span class=p>);</span>
  <span class=k>auto</span> <span class=n>program</span> <span class=o>=</span> <span class=n>staq</span><span class=o>-&gt;</span><span class=n>compile</span><span class=p>(</span><span class=n>oqasm_src</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>getComposites</span><span class=p>()[</span><span class=mi>0</span><span class=p>];</span>

  <span class=c1>// Add all Instructions in program to this Circuit
</span><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>program</span><span class=o>-&gt;</span><span class=n>nInstructions</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>addInstruction</span><span class=p>(</span><span class=n>program</span><span class=o>-&gt;</span><span class=n>getInstruction</span><span class=p>(</span><span class=n>i</span><span class=p>));</span>
  <span class=p>}</span>

  <span class=c1>// We suceeded, return true
</span><span class=c1></span>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>PyQsearch</span><span class=o>::</span><span class=n>requiredKeys</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=p>{</span><span class=s>&#34;unitary&#34;</span><span class=p>};</span> <span class=p>}</span>
<span class=p>}</span> <span class=c1>// namespace circuits
</span><span class=c1></span><span class=p>}</span> <span class=c1>// namespace xacc
</span><span class=c1></span>
<span class=c1>// Must register this plugin as an Instruction!
</span><span class=c1></span><span class=n>REGISTER_PLUGIN</span><span class=p>(</span><span class=n>xacc</span><span class=o>::</span><span class=n>circuits</span><span class=o>::</span><span class=n>MyCircSynth</span><span class=p>,</span> <span class=n>xacc</span><span class=o>::</span><span class=n>Instruction</span><span class=p>)</span>
</code></pre></div><p>The goal of the <code>expand</code> implementation is to extract the incoming unitary matrix, run your custom circuit synthesis strategy on it, and
then map that result to XACC <code>Instructions</code> which can then be added to <code>this</code> `Circuit.</p><p>Build and install this plugin with the following commands (from the top-level of the project directory)</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>mkdir build <span class=o>&amp;&amp;</span> <span class=nb>cd</span> build 
cmake .. -G Ninja -DXACC_DIR<span class=o>=</span><span class=k>$(</span>qcor -xacc-install<span class=k>)</span>
cmake --build . --target install
</code></pre></div><p>Now to use this within the AIDE-QC stack</p><table><tr><th>MyCircSynth in C++</th><th>MyCircSynth in Python</th></tr><tr><td><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>__qpu__</span> <span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=n>qreg</span> <span class=n>q</span><span class=p>)</span> <span class=p>{</span>

    <span class=n>decompose</span> <span class=p>{</span>
        <span class=n>UnitaryMatrix</span> <span class=n>u</span> <span class=o>=</span> <span class=n>UnitaryMatrix</span><span class=o>::</span><span class=n>Identity</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
        <span class=c1>// fill matrix
</span><span class=c1></span>    <span class=p>}(</span><span class=n>q</span><span class=p>,</span> <span class=n>my_circ_synth</span><span class=p>)</span>

<span class=p>}</span>
</code></pre></div></td><td><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=o>*</span>

<span class=nd>@qjit</span>
<span class=k>def</span> <span class=nf>foo</span><span class=p>(</span><span class=n>q</span> <span class=p>:</span> <span class=n>qreg</span><span class=p>):</span>
    <span class=k>with</span> <span class=n>decompose</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=n>my_circ_synth</span><span class=p>)</span> <span class=k>as</span> <span class=n>u</span><span class=p>:</span>
        <span class=c1># fill u...</span>

</code></pre></div></td></tr></table><div class=edit-meta><br><a href=https://github.com/aide-qc/deploy//edit/master/website/content/developers/implement_circuit_synthesis.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/deploy/developers/ title="Developer Guide"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Developer Guide</a>
<a class="nav nav-next" href=/deploy/developers/implement_optimizer/ title="Add a New Optimizer">Next - Add a New Optimizer <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://aide-qc.github.io/deploy>Home</a></li><li class=has-sub-menu><a href=/deploy/background/>Background<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/background/qcor/>QCOR C++ Compiler and JIT Engine</a></li><li><a href=/deploy/background/xacc/>XACC Quantum Programming Framework</a></li><li><a href=/deploy/background/project/></a></li></ul></li><li class="parent has-sub-menu"><a href=/deploy/developers/>Developer Guide<span class="mark opened">-</span></a><ul class=sub-menu><li class=active><a href=/deploy/developers/implement_circuit_synthesis/>Add a New Circuit Synthesis Strategy</a></li><li><a href=/deploy/developers/implement_optimizer/>Add a New Optimizer</a></li><li><a href=/deploy/developers/implement_qsim_workflow/>Add a New QSim Workflow</a></li><li><a href=/deploy/developers/implement_accelerator/>Add a New Quantum Backend</a></li><li><a href=/deploy/developers/implement_plugin_embedded_python/>Hybrid C++ / Python Plugins</a></li><li><a href=/deploy/developers/clang_syntax/></a></li></ul></li><li class=has-sub-menu><a href=/deploy/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/getting_started/Faq/>Frequently Asked Questions</a></li><li><a href=/deploy/getting_started/build_from_source/>Build Everything from Source</a></li></ul></li><li class=has-sub-menu><a href=/deploy/users/>User Guide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/users/hello_world/>Hello World</a></li><li><a href=/deploy/users/operators/>Operators</a></li><li><a href=/deploy/users/pass_manager/>Pass Manager</a></li><li><a href=/deploy/users/qjit/>Quantum JIT (QJIT)</a></li><li><a href=/deploy/users/quantum_kernels/>Quantum Kernels</a></li><li><a href=/deploy/users/qsim/>Quantum Simulation (QSim)</a></li><li><a href=/deploy/users/remote_qpu_creds/>Remote QPU Credentials</a></li><li><a href=/deploy/users/tnqvm/>Tensor Network Quantum Virtual Machine</a></li><li><a href=/deploy/users/using_optimizer/>Using an Optimizer</a></li><li><a href=/deploy/users/variational/>Variational Algorithms</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>