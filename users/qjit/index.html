<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Quantum JIT (QJIT) - AIDE-QC</title><meta name=description content="Advancing Integrated Development Environments for Quantum Computing"><meta name=generator content="Hugo 0.76.5"><link href=https://aide-qc.github.io/deployindex.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://aide-qc.github.io/deploy/users/qjit/><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://aide-qc.github.io/deploy/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://aide-qc.github.io/deploy/aide_qc_logo_v3.png width=40px align=absmiddle>
AIDE-QC</div></h1><p class=description>Advancing Integrated Development Environments for Quantum Computing</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://aideqc.slack.com>AIDE-QC Slack</a></li><li class=child><a href=https://xacc-dev.slack.com>XACC/QCOR Slack</a></li></ul></li><li class=parent><a href=https://github.com/aide-qc>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://ornl-qci.github.io/qcor-api-docs/>QCOR Doxygen</a></li><li class=child><a href=https://ornl-qci.github.io/xacc-api-docs/>XACC Doxygen</a></li><li class=child><a href=https://github.com/aide-qc/qcor>QCOR</a></li><li class=child><a href=https://github.com/aide-qc/xacc>XACC</a></li></ul></li><li><a href=https://github.com/aide-qc/aide-qc/issues>Bugs</a></li><li><a href=http://aide-qc.org>Project Page</a></li></ul></nav></div><div class=content-container><main><h1>Quantum JIT (QJIT)</h1><p>The quantum kernel programming model in C++ for the AIDE-QC stack relies on a novel
Clang plugin interface called the
<a href=/deploy/developers/clang_syntax/>SyntaxHandler</a>
. This infrastructure
enables quantum programming with annotated C++ functions in a language agnostic manner. A downside to
this is that quantum kernels are defined at compile-time and are therefore less-flexible for use cases
where runtime-generated circuits are useful.</p><p>To address this, we have put forward an infrastructure for just-in-time compilation of quantum kernels.
This infrastructure enables one to programmatically run the <code>SyntaxHandler</code> workflow and compile
the resultant C++ API code to an LLVM
<a href=https://llvm.org/doxygen/classllvm_1_1Module.html>Module</a>
. This <code>Module</code>
is used as input to the LLVM JIT infrastructure which enables us to create function pointers to
compiled quantum kernels at runtime.</p><p>We have packaged this infrastructure into a simple, easy-to-use <code>QJIT</code> class. This class exposes a <code>jit_compile()</code>
method that takes C++ quantum kernels and executes the entire <code>SyntaxHandler</code> -> LLVM IR &ndash;> LLVM JIT workflow.</p><p>Let&rsquo;s demonstrate how one might use this in C++:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// To use the QCOR JIT utilities 
</span><span class=c1>// just include the qcor_jit.hpp header
</span><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;qcor_jit.hpp&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>

  <span class=c1>// QJIT is the entry point to QCOR quantum kernel 
</span><span class=c1></span>  <span class=c1>// just in time compilation
</span><span class=c1></span>  <span class=n>QJIT</span> <span class=n>qjit</span><span class=p>;</span>

  <span class=c1>// Define a quantum kernel string dynamically
</span><span class=c1></span>  <span class=k>const</span> <span class=k>auto</span> <span class=n>kernel_src</span> <span class=o>=</span> <span class=n>R</span><span class=s>&#34;#(__qpu__ void bell(qreg q) {</span>
        <span class=k>using</span> <span class=n>qcor</span><span class=o>::</span><span class=n>openqasm</span><span class=p>;</span>
        <span class=n>h</span> <span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
        <span class=n>cx</span> <span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
        <span class=n>creg</span> <span class=n>c</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
        <span class=n>measure</span> <span class=n>q</span> <span class=o>-&gt;</span> <span class=n>c</span><span class=p>;</span>
    <span class=p>})</span><span class=err>#</span><span class=s>&#34;;</span>

  <span class=c1>// Use the QJIT instance to compile this at runtime
</span><span class=c1></span>  <span class=n>qjit</span><span class=p>.</span><span class=n>jit_compile</span><span class=p>(</span><span class=n>kernel_src</span><span class=p>);</span>

  <span class=c1>// Now, one can get the compiled kernel as a 
</span><span class=c1></span>  <span class=c1>// functor to execute, must provide the kernel 
</span><span class=c1></span>  <span class=c1>// argument types as template parameters
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>bell_functor</span> <span class=o>=</span> <span class=n>qjit</span><span class=p>.</span><span class=n>get_kernel</span><span class=o>&lt;</span><span class=n>qreg</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;bell&#34;</span><span class=p>);</span>

  <span class=c1>// Allocate some qubits and run the kernel functor
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>q</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
  <span class=n>bell_functor</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
  <span class=n>q</span><span class=p>.</span><span class=n>print</span><span class=p>();</span>

  <span class=c1>// Or, one can call the QJIT invoke method 
</span><span class=c1></span>  <span class=c1>// with the name of the kernel function and 
</span><span class=c1></span>  <span class=c1>// the necessary function arguments.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>r</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
  <span class=n>qjit</span><span class=p>.</span><span class=n>invoke</span><span class=p>(</span><span class=s>&#34;bell&#34;</span><span class=p>,</span> <span class=n>r</span><span class=p>);</span>
  <span class=n>r</span><span class=p>.</span><span class=n>print</span><span class=p>();</span>

  <span class=c1>// Note, if QCOR QJIT has not seen this kernel 
</span><span class=c1></span>  <span class=c1>// source code before, it will run through the 
</span><span class=c1></span>  <span class=c1>// entire JIT compile process. If you have run 
</span><span class=c1></span>  <span class=c1>// this JIT compile before, QCOR QJIT will read a 
</span><span class=c1></span>  <span class=c1>// cached representation of the kernel and load that, 
</span><span class=c1></span>  <span class=c1>// increasing JIT compile performance. 
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>The <code>QJIT</code> class is provided by the <code>qcor_jit.hpp</code> header. Programmers simply instantiate the data structure, define the kernel source code string, and
invoke the <code>jit_compile</code> method. This will internally store pointers to the compiled quantum kernel functions, which you can access via the <code>get_kernel&lt;T...>(name:string)</code> method, which takes the argument types and the name of the kernel. This function pointer can be called just like one would call a pre-defined quantum kernel funciton. One can also use the <code>invoke(name:string, args:T...)</code> method, which will invoke the internal function pointer with the given arguments.</p><p>A key feature of this workflow is that all compiled kernel LLVM IR <code>Modules</code> are cached. This means that after the first <code>jit_compile</code> call for a given kernel string, the resultant <code>Module</code> bitcode will be stored and associated with a unique hash for the kernel source string. Everytime this code is run again, the execution time will be faster because internally we will load the cached <code>Module</code> instead of going through the entire compile workflow.</p><p>One can also use this infrastructure from Python:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=n>QJIT</span><span class=p>,</span> <span class=n>qreg</span><span class=p>,</span> <span class=n>qalloc</span>

<span class=c1># Instantiate the QJIT</span>
<span class=n>qjit</span> <span class=o>=</span> <span class=n>QJIT</span><span class=p>()</span>

<span class=c1># Define your kernel source</span>
<span class=n>kernel_src</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;__qpu__ void bell(qreg q) {
</span><span class=s1>        using qcor::openqasm;
</span><span class=s1>        h q[0];
</span><span class=s1>        cx q[0], q[1];
</span><span class=s1>        creg c[2];
</span><span class=s1>        measure q -&gt; c;
</span><span class=s1>    }&#39;&#39;&#39;</span>

<span class=c1># JIT Compile</span>
<span class=n>qjit</span><span class=o>.</span><span class=n>jit_compile</span><span class=p>(</span><span class=n>kernel_src</span><span class=p>)</span>

<span class=c1># Invoke the kernel.</span>
<span class=c1># Note, in Python we have to provide the args as </span>
<span class=c1># a dict, where keys have to match the arg </span>
<span class=c1># name in the kernel source</span>
<span class=n>q</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
<span class=n>qjit</span><span class=o>.</span><span class=n>invoke</span><span class=p>(</span><span class=s1>&#39;bell&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;q&#39;</span><span class=p>:</span><span class=n>q</span><span class=p>})</span>
<span class=n>q</span><span class=o>.</span><span class=k>print</span><span class=p>()</span>

<span class=c1># You could also view the re-written C++ src</span>
<span class=n>auto</span> <span class=p>[</span><span class=n>kernel_name</span><span class=p>,</span> <span class=n>cpp_src</span><span class=p>]</span> <span class=o>=</span> <span class=n>qjit</span><span class=o>.</span><span class=n>run_syntax_handler</span><span class=p>(</span><span class=n>kernel_src</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=n>cpp_src</span><span class=p>)</span>
</code></pre></div><h2 id=a-idpyqjita-pythonic-qjit><a id=pyqjit></a>Pythonic <code>@qjit</code>&nbsp;<a class=headline-hash href=#a-idpyqjita-pythonic-qjit>¶</a></h2><p>We leverage the above C++ <code>QJIT</code> infrastructure to enable a single-source programming model for
quantum-classical computing in Python. To do so, we have defined a new domain specific language that is
supported by our Clang Syntax Handler infrastructure that is XASM-like, but in Python. This language enables programmers to program quantum instructions in a manner that is acceptable to the first-pass of the Python interpreter&rsquo;s syntax check. We have defined a novel Python decorator, <code>@qjit</code>, that programmers leverage to defined Python functions written in our available pythonic XASM dialect (as well as a
<a href=/deploy/users/quantum_kernels/#pyxasm_unitary>unitary matrix decomposition language</a>
). This decorator provides a mechanism for analyzing the decorated function body (written in the <code>pyxasm</code> dialect) and just-in-time compiling it with the above C++ <code>QJIT</code> class. This mechanism produces an internal C++ function pointer that is called whenever the <code>qjit.__call__(*args)</code> method is invoked.</p><p>Check out this simple GHZ state example</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=n>qjit</span><span class=p>,</span> <span class=n>qalloc</span><span class=p>,</span> <span class=n>qreg</span>

<span class=nd>@qjit</span>
<span class=k>def</span> <span class=nf>ghz</span><span class=p>(</span><span class=n>q</span> <span class=p>:</span> <span class=n>qreg</span><span class=p>):</span>
    <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>q</span><span class=o>.</span><span class=n>size</span><span class=p>()</span><span class=o>-</span><span class=mi>1</span><span class=p>):</span>
        <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>q</span><span class=o>.</span><span class=n>size</span><span class=p>()):</span>
        <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>

<span class=n>q</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
<span class=n>ghz</span><span class=p>(</span><span class=n>q</span><span class=p>)</span>
<span class=k>for</span> <span class=n>bits</span><span class=p>,</span> <span class=n>counts</span> <span class=ow>in</span> <span class=n>q</span><span class=o>.</span><span class=n>counts</span><span class=p>()</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
    <span class=k>print</span><span class=p>(</span><span class=n>bits</span><span class=p>,</span> <span class=s1>&#39;:&#39;</span><span class=p>,</span> <span class=n>counts</span><span class=p>)</span>
</code></pre></div><p>The <code>qjit.__init__()</code> method will leverage the
<a href=https://docs.python.org/3/library/inspect.html>inspect</a>
module to analyze and pre-process the source code representation of the function body, and send the source string to the <code>QJIT::jit_compile()</code> call, kicking off the <code>Syntax Handler -> Clang CodeGen -> LLVM Module -> LLVM JIT -> Function Pointer</code> workflow. The function pointer is invoked when <code>ghz(q)</code> is called.</p><p><code>qjit</code> exposes a number of methods that make it easy to query information about the kernel, or to map it to other representations. Let&rsquo;s demonstrate this for the GHZ state</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=n>qjit</span><span class=p>,</span> <span class=n>qalloc</span><span class=p>,</span> <span class=n>qreg</span>

<span class=nd>@qjit</span>
<span class=k>def</span> <span class=nf>ghz</span><span class=p>(</span><span class=n>q</span> <span class=p>:</span> <span class=n>qreg</span><span class=p>):</span>
    <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>q</span><span class=o>.</span><span class=n>size</span><span class=p>()</span><span class=o>-</span><span class=mi>1</span><span class=p>):</span>
        <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>q</span><span class=o>.</span><span class=n>size</span><span class=p>()):</span>
        <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>

<span class=n>q</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>

<span class=k>print</span><span class=p>(</span><span class=s1>&#39;Kernel Name: &#39;</span><span class=p>,</span> <span class=n>ghz</span><span class=o>.</span><span class=n>kernel_name</span><span class=p>())</span>
<span class=k>print</span><span class=p>(</span><span class=s1>&#39;N Instructions: &#39;</span><span class=p>,</span> <span class=n>ghz</span><span class=o>.</span><span class=n>n_instructions</span><span class=p>(</span><span class=n>q</span><span class=p>))</span>

<span class=k>print</span><span class=p>(</span><span class=s1>&#39;As OpenQasm:</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>ghz</span><span class=o>.</span><span class=n>openqasm</span><span class=p>(</span><span class=n>q</span><span class=p>))</span>
<span class=k>print</span><span class=p>(</span><span class=s1>&#39;As XASM:</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span>
<span class=n>ghz</span><span class=o>.</span><span class=n>print_kernel</span><span class=p>(</span><span class=n>q</span><span class=p>)</span>

<span class=c1># For Developers and Debugging</span>
<span class=k>print</span><span class=p>(</span><span class=s1>&#39;Src code sent to QJIT:</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>ghz</span><span class=o>.</span><span class=n>get_internal_src</span><span class=p>()</span> <span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s1>&#39;Src code compiled to LLVM IR:</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>ghz</span><span class=o>.</span><span class=n>get_syntax_handler_src</span><span class=p>())</span>
</code></pre></div><p>This will print the following:</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>Kernel Name:  ghz
N Instructions:  <span class=m>10</span>
As OpenQasm:
 OPENQASM 2.0<span class=p>;</span>
include <span class=s2>&#34;qelib1.inc&#34;</span><span class=p>;</span>
qreg qrg_nWlrB<span class=o>[</span>5<span class=o>]</span><span class=p>;</span>
creg qrg_nWlrB_c<span class=o>[</span>5<span class=o>]</span><span class=p>;</span>
h qrg_nWlrB<span class=o>[</span>0<span class=o>]</span><span class=p>;</span>
CX qrg_nWlrB<span class=o>[</span>0<span class=o>]</span>, qrg_nWlrB<span class=o>[</span>1<span class=o>]</span><span class=p>;</span>
CX qrg_nWlrB<span class=o>[</span>1<span class=o>]</span>, qrg_nWlrB<span class=o>[</span>2<span class=o>]</span><span class=p>;</span>
CX qrg_nWlrB<span class=o>[</span>2<span class=o>]</span>, qrg_nWlrB<span class=o>[</span>3<span class=o>]</span><span class=p>;</span>
CX qrg_nWlrB<span class=o>[</span>3<span class=o>]</span>, qrg_nWlrB<span class=o>[</span>4<span class=o>]</span><span class=p>;</span>
measure qrg_nWlrB<span class=o>[</span>0<span class=o>]</span> -&gt; qrg_nWlrB_c<span class=o>[</span>0<span class=o>]</span><span class=p>;</span>
measure qrg_nWlrB<span class=o>[</span>1<span class=o>]</span> -&gt; qrg_nWlrB_c<span class=o>[</span>1<span class=o>]</span><span class=p>;</span>
measure qrg_nWlrB<span class=o>[</span>2<span class=o>]</span> -&gt; qrg_nWlrB_c<span class=o>[</span>2<span class=o>]</span><span class=p>;</span>
measure qrg_nWlrB<span class=o>[</span>3<span class=o>]</span> -&gt; qrg_nWlrB_c<span class=o>[</span>3<span class=o>]</span><span class=p>;</span>
measure qrg_nWlrB<span class=o>[</span>4<span class=o>]</span> -&gt; qrg_nWlrB_c<span class=o>[</span>4<span class=o>]</span><span class=p>;</span>

H qrg_nWlrB0
CNOT qrg_nWlrB0,qrg_nWlrB1
CNOT qrg_nWlrB1,qrg_nWlrB2
CNOT qrg_nWlrB2,qrg_nWlrB3
CNOT qrg_nWlrB3,qrg_nWlrB4
Measure qrg_nWlrB0
Measure qrg_nWlrB1
Measure qrg_nWlrB2
Measure qrg_nWlrB3
Measure qrg_nWlrB4

As XASM:
 None
Src code sent to QJIT:
 __qpu__ void ghz<span class=o>(</span>qreg q<span class=o>)</span> <span class=o>{</span>
using qcor::pyxasm<span class=p>;</span>

    H<span class=o>(</span>q<span class=o>[</span>0<span class=o>])</span>
    <span class=k>for</span> i in range<span class=o>(</span>q.size<span class=o>()</span>-1<span class=o>)</span>:
        CX<span class=o>(</span>q<span class=o>[</span>i<span class=o>]</span>, q<span class=o>[</span>i+1<span class=o>])</span>
    <span class=k>for</span> i in range<span class=o>(</span>q.size<span class=o>())</span>:
        Measure<span class=o>(</span>q<span class=o>[</span>i<span class=o>])</span>
<span class=o>}</span>

Src code compiled to LLVM IR:
 void ghz<span class=o>(</span>qreg q<span class=o>)</span> <span class=o>{</span>
void __internal_call_function_ghz<span class=o>(</span>qreg<span class=o>)</span><span class=p>;</span>
__internal_call_function_ghz<span class=o>(</span>q<span class=o>)</span><span class=p>;</span>
<span class=o>}</span>
class ghz : public qcor::QuantumKernel&lt;class ghz, qreg&gt; <span class=o>{</span>
friend class qcor::QuantumKernel&lt;class ghz, qreg&gt;<span class=p>;</span>
protected:
void operator<span class=o>()(</span>qreg q<span class=o>)</span> <span class=o>{</span>
<span class=k>if</span> <span class=o>(</span>!parent_kernel<span class=o>)</span> <span class=o>{</span>
<span class=nv>parent_kernel</span> <span class=o>=</span> qcor::__internal__::create_composite<span class=o>(</span>kernel_name<span class=o>)</span><span class=p>;</span>
<span class=o>}</span>
quantum::set_current_program<span class=o>(</span>parent_kernel<span class=o>)</span><span class=p>;</span>
<span class=k>if</span> <span class=o>(</span><span class=nv>runtime_env</span> <span class=o>==</span> QrtType::FTQC<span class=o>)</span> <span class=o>{</span>
quantum::set_current_buffer<span class=o>(</span>q.results<span class=o>())</span><span class=p>;</span>
<span class=o>}</span>
quantum::h<span class=o>(</span>q<span class=o>[</span>0<span class=o>])</span><span class=p>;</span>
<span class=k>for</span> <span class=o>(</span>auto <span class=p>&amp;</span>i : range<span class=o>(</span>q.size<span class=o>()</span>-1<span class=o>))</span> <span class=o>{</span>
quantum::cnot<span class=o>(</span>q<span class=o>[</span>i<span class=o>]</span>, q<span class=o>[</span>i+1<span class=o>])</span><span class=p>;</span>
<span class=o>}</span>
<span class=k>for</span> <span class=o>(</span>auto <span class=p>&amp;</span>i : range<span class=o>(</span>q.size<span class=o>()))</span> <span class=o>{</span>
quantum::mz<span class=o>(</span>q<span class=o>[</span>i<span class=o>])</span><span class=p>;</span>
<span class=o>}</span>

<span class=o>}</span>
public:
inline static const std::string <span class=nv>kernel_name</span> <span class=o>=</span> <span class=s2>&#34;ghz&#34;</span><span class=p>;</span>
ghz<span class=o>(</span>qreg q<span class=o>)</span>: QuantumKernel&lt;ghz, qreg&gt; <span class=o>(</span>q<span class=o>)</span> <span class=o>{}</span>
ghz<span class=o>(</span>std::shared_ptr&lt;qcor::CompositeInstruction&gt; _parent, qreg q<span class=o>)</span>: QuantumKernel&lt;ghz, qreg&gt; <span class=o>(</span>_parent, q<span class=o>)</span> <span class=o>{}</span>
virtual ~ghz<span class=o>()</span> <span class=o>{</span>
<span class=k>if</span> <span class=o>(</span>disable_destructor<span class=o>)</span> <span class=o>{</span><span class=k>return</span><span class=p>;</span><span class=o>}</span>
auto <span class=o>[</span>q<span class=o>]</span> <span class=o>=</span> args_tuple<span class=p>;</span>
operator<span class=o>()(</span>q<span class=o>)</span><span class=p>;</span>
<span class=k>if</span> <span class=o>(</span><span class=nv>runtime_env</span> <span class=o>==</span> QrtType::FTQC<span class=o>)</span> <span class=o>{</span>
<span class=k>if</span> <span class=o>(</span>is_callable<span class=o>)</span> <span class=o>{</span>
quantum::persistBitstring<span class=o>(</span>q.results<span class=o>())</span><span class=p>;</span>
<span class=k>for</span> <span class=o>(</span>size_t <span class=nv>shotCount</span> <span class=o>=</span> 1<span class=p>;</span> shotCount &lt; quantum::get_shots<span class=o>()</span><span class=p>;</span> ++shotCount<span class=o>)</span> <span class=o>{</span>
operator<span class=o>()(</span>q<span class=o>)</span><span class=p>;</span>
quantum::persistBitstring<span class=o>(</span>q.results<span class=o>())</span><span class=p>;</span>
<span class=o>}</span>
<span class=o>}</span>
<span class=k>return</span><span class=p>;</span>
<span class=o>}</span>
xacc::internal_compiler::execute_pass_manager<span class=o>()</span><span class=p>;</span>
<span class=k>if</span> <span class=o>(</span>optimize_only<span class=o>)</span> <span class=o>{</span>
<span class=k>return</span><span class=p>;</span>
<span class=o>}</span>
<span class=k>if</span> <span class=o>(</span>is_callable<span class=o>)</span> <span class=o>{</span>
quantum::submit<span class=o>(</span>q.results<span class=o>())</span><span class=p>;</span>
<span class=o>}</span>
<span class=o>}</span>
<span class=o>}</span><span class=p>;</span>
void ghz<span class=o>(</span>std::shared_ptr&lt;qcor::CompositeInstruction&gt; parent, qreg q<span class=o>)</span> <span class=o>{</span>
class ghz __ker__temp__<span class=o>(</span>parent, q<span class=o>)</span><span class=p>;</span>
<span class=o>}</span>
void __internal_call_function_ghz<span class=o>(</span>qreg q<span class=o>)</span> <span class=o>{</span>
class ghz __ker__temp__<span class=o>(</span>q<span class=o>)</span><span class=p>;</span>
<span class=o>}</span>
void ghz__with_hetmap_args<span class=o>(</span>HeterogeneousMap<span class=p>&amp;</span> args<span class=o>)</span> <span class=o>{</span>
class ghz __ker__temp__<span class=o>(</span>args.get&lt;qreg&gt;<span class=o>(</span><span class=s2>&#34;q&#34;</span><span class=o>))</span><span class=p>;</span>
<span class=o>}</span>
void ghz__with_parent_and_hetmap_args<span class=o>(</span>std::shared_ptr&lt;CompositeInstruction&gt; parent, HeterogeneousMap<span class=p>&amp;</span> args<span class=o>)</span> <span class=o>{</span>
class ghz __ker__temp__<span class=o>(</span>parent, args.get&lt;qreg&gt;<span class=o>(</span><span class=s2>&#34;q&#34;</span><span class=o>))</span><span class=p>;</span>
<span class=o>}</span>


// Fix <span class=k>for</span> __dso_handle symbol not found
<span class=c1>#ifndef __FIX__DSO__HANDLE__</span>
<span class=c1>#define __FIX__DSO__HANDLE__ </span>
int <span class=nv>__dso_handle</span> <span class=o>=</span> 1<span class=p>;</span>
<span class=c1>#endif</span>
</code></pre></div><p>One can also use <code>qjit</code> on an un-measured parameterized quantum kernel in order to compute the expectation value with respect to some provided <code>Operator</code>.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=o>*</span>

<span class=n>H</span> <span class=o>=</span> <span class=o>-</span><span class=mf>2.1433</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mf>2.1433</span> <span class=o>*</span> \
    <span class=n>Y</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=o>.</span><span class=mi>21829</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>-</span> <span class=mf>6.125</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mf>5.907</span>

<span class=nd>@qjit</span>
<span class=k>def</span> <span class=nf>ansatz</span><span class=p>(</span><span class=n>q</span> <span class=p>:</span> <span class=n>qreg</span><span class=p>,</span> <span class=n>theta</span> <span class=p>:</span> <span class=nb>float</span><span class=p>):</span>
    <span class=n>X</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=n>Ry</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>theta</span><span class=p>)</span>
    <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>

<span class=n>q</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
<span class=c1># Note, first arg is the Operator, followed</span>
<span class=c1># by the args required by the kernel</span>
<span class=n>energy</span> <span class=o>=</span> <span class=n>ansatz</span><span class=o>.</span><span class=n>observe</span><span class=p>(</span><span class=n>H</span><span class=p>,</span> <span class=n>q</span><span class=p>,</span> <span class=o>.</span><span class=mi>59</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=n>energy</span><span class=p>)</span>
</code></pre></div><h3 id=a-idpyqjit_translatea-advanced-variational-argument-translation><a id=pyqjit_translate></a>Advanced Variational Argument Translation&nbsp;<a class=headline-hash href=#a-idpyqjit_translatea-advanced-variational-argument-translation>¶</a></h3><p>For advanced use cases that leverage variational algorithms through the AIDE-QC API, where the kernel argument structure may not be a simple float or list of floats, programmers need to provide a mechanism for translating between a list of floats (circuit parameters) and the argument structure for the kernel. Let&rsquo;s look at the following QAOA example</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=o>*</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>
<span class=kn>from</span> <span class=nn>types</span> <span class=kn>import</span> <span class=n>MethodType</span>

<span class=c1># Define a QAOA kernel with variational parameters (theta and beta angles)</span>
<span class=nd>@qjit</span>
<span class=k>def</span> <span class=nf>qaoa_circ</span><span class=p>(</span><span class=n>q</span><span class=p>:</span> <span class=n>qreg</span><span class=p>,</span> <span class=n>cost_ham</span><span class=p>:</span> <span class=n>PauliOperator</span><span class=p>,</span> <span class=n>nbSteps</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>gamma</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>float</span><span class=p>],</span> <span class=n>beta</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>float</span><span class=p>]):</span>
    <span class=c1># Start off in the uniform superposition</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>q</span><span class=o>.</span><span class=n>size</span><span class=p>()):</span>
        <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
    
    <span class=n>terms</span> <span class=o>=</span> <span class=n>cost_ham</span><span class=o>.</span><span class=n>getNonIdentitySubTerms</span><span class=p>()</span>
    <span class=k>for</span> <span class=n>step</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>nbSteps</span><span class=p>):</span>
        <span class=k>for</span> <span class=n>term</span> <span class=ow>in</span> <span class=n>terms</span><span class=p>:</span>
            <span class=n>exp_i_theta</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=n>theta</span><span class=p>[</span><span class=n>step</span><span class=p>],</span> <span class=n>term</span><span class=p>)</span>

        <span class=c1># Reference Hamiltonian: </span>
        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>q</span><span class=p>)):</span>
            <span class=n>ref_ham_term</span> <span class=o>=</span> <span class=n>X</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
            <span class=n>exp_i_theta</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=n>beta</span><span class=p>[</span><span class=n>step</span><span class=p>],</span> <span class=n>ref_ham_term</span><span class=p>)</span>
   
<span class=c1># Allocate 4 qubits</span>
<span class=n>q</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
<span class=n>n_steps</span> <span class=o>=</span> <span class=mi>3</span>
<span class=c1># Hamiltonion:</span>
<span class=n>H</span> <span class=o>=</span> <span class=o>-</span><span class=mf>5.0</span> <span class=o>-</span> <span class=mf>0.5</span> <span class=o>*</span> <span class=p>(</span><span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>-</span> <span class=n>Z</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=o>-</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span> <span class=o>-</span> <span class=n>Z</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>+</span> <span class=mf>2.5</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>

<span class=c1># Custom arg_translator in a Pythonic way</span>
<span class=k>def</span> <span class=nf>qaoa_translate</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>q</span><span class=p>:</span> <span class=n>qreg</span><span class=p>,</span> <span class=n>x</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>float</span><span class=p>]):</span>
    <span class=n>ret_dict</span> <span class=o>=</span> <span class=p>{}</span>    
    <span class=n>ret_dict</span><span class=p>[</span><span class=s2>&#34;q&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>q</span>
    <span class=n>ret_dict</span><span class=p>[</span><span class=s2>&#34;cost_ham&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>H</span>
    <span class=n>ret_dict</span><span class=p>[</span><span class=s2>&#34;nbSteps&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>n_steps</span>
    <span class=n>ret_dict</span><span class=p>[</span><span class=s2>&#34;theta&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span><span class=p>[:</span><span class=n>n_steps</span><span class=p>]</span>
    <span class=n>ret_dict</span><span class=p>[</span><span class=s2>&#34;beta&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span><span class=p>[</span><span class=n>n_steps</span><span class=p>:]</span>
    <span class=k>return</span> <span class=n>ret_dict</span>

<span class=c1># Rebind arg translate:</span>
<span class=n>qaoa_circ</span><span class=o>.</span><span class=n>translate</span> <span class=o>=</span> <span class=n>MethodType</span><span class=p>(</span><span class=n>qaoa_translate</span><span class=p>,</span> <span class=n>qjit</span><span class=p>)</span>

<span class=c1># Use the standard parameterization scheme: </span>
<span class=c1># one theta + one beta per step</span>
<span class=n>n_params</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>n_steps</span>
<span class=n>obj</span> <span class=o>=</span> <span class=n>createObjectiveFunction</span><span class=p>(</span><span class=n>qaoa_circ</span><span class=p>,</span> <span class=n>H</span><span class=p>,</span> <span class=n>n_params</span><span class=p>)</span>

<span class=c1># Run optimization</span>
<span class=n>optimizer</span> <span class=o>=</span> <span class=n>createOptimizer</span><span class=p>(</span><span class=s1>&#39;nlopt&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;initial-parameters&#39;</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=n>n_params</span><span class=p>)})</span>
<span class=n>results</span> <span class=o>=</span> <span class=n>optimizer</span><span class=o>.</span><span class=n>optimize</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span>
</code></pre></div><p>Here we have a quantum kernel <code>qaoa_circ</code> that is building up the QAOA ansatz for a provided cost Hamiltonian. Input to the kernel is the <code>qreg</code>, the cost Hamiltonian, the number of QAOA steps, and the cost and mixing parameters, <code>gamma</code> and <code>beta</code>. In order to leverage this ansatz with <code>ObjectiveFunction</code> or the <code>QuaSiMo</code> library, we must provide a mechanism for translating variational parameters <code>x : List[float]</code> to kernel arguments.</p><p>To accomplish this, we require programmers to specify a function that takes a <code>qreg</code> and a <code>List[float]</code> and creates and returns a dictionary mapping kernel argument variable names to concrete values (either from global scope or from the incoming <code>List[float]</code>). In the QAOA example, we take global <code>H</code> and <code>n_steps</code> and map them to the corresponding argument variable name in the kernel definition. We also split the incoming <code>List[float]</code> and map them to <code>gamma</code> and <code>beta</code> keys. To inject this translation function into the <code>qjit</code> instance, we leverage <code>types.MethodType</code> and set the <code>qjit</code> instance (the function name) <code>translate</code> method. We are now free to use this parameterized kernel within the variational datastructures exposed by the AIDE-QC stack.</p><div class=edit-meta><br><a href=https://github.com/aide-qc/deploy//edit/master/website/content/users/qjit.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/deploy/users/pass_manager/ title="Pass Manager"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Pass Manager</a>
<a class="nav nav-next" href=/deploy/users/quantum_kernels/ title="Quantum Kernels">Next - Quantum Kernels <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://aide-qc.github.io/deploy>Home</a></li><li class=has-sub-menu><a href=/deploy/background/>Background<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/background/qcor/>QCOR C++ Compiler and JIT Engine</a></li><li><a href=/deploy/background/xacc/>XACC Quantum Programming Framework</a></li><li><a href=/deploy/background/project/></a></li></ul></li><li class=has-sub-menu><a href=/deploy/developers/>Developer Guide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/developers/implement_circuit_synthesis/>Add a New Circuit Synthesis Strategy</a></li><li><a href=/deploy/developers/implement_optimizer/>Add a New Optimizer</a></li><li><a href=/deploy/developers/implement_accelerator/>Add a New Quantum Backend</a></li><li><a href=/deploy/developers/implement_quasimo_workflow/>Add a New QuaSiMo Workflow</a></li><li><a href=/deploy/developers/implement_plugin_embedded_python/>Hybrid C++ / Python Plugins</a></li><li><a href=/deploy/developers/clang_syntax/></a></li></ul></li><li class=has-sub-menu><a href=/deploy/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/getting_started/Faq/>Frequently Asked Questions</a></li><li><a href=/deploy/getting_started/build_from_source/>Build Everything from Source</a></li></ul></li><li class=has-sub-menu><a href=/deploy/lang_spec/>QCOR Classical Language Extension<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/lang_spec/data_model/>Data Model</a></li><li><a href=/deploy/lang_spec/exec_model/>Execution Model</a></li><li><a href=/deploy/lang_spec/memory/>Memory Model</a></li><li><a href=/deploy/lang_spec/prog_model/>Programming Model</a></li></ul></li><li class="parent has-sub-menu"><a href=/deploy/users/>User Guide<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/deploy/users/hello_world/>Hello World</a></li><li><a href=/deploy/users/operators/>Operators</a></li><li><a href=/deploy/users/pass_manager/>Pass Manager</a></li><li class=active><a href=/deploy/users/qjit/>Quantum JIT (QJIT)</a></li><li><a href=/deploy/users/quantum_kernels/>Quantum Kernels</a></li><li><a href=/deploy/users/quasimo/>Quantum Simulation Modeling (QuaSiMo)</a></li><li><a href=/deploy/users/remote_qpu_creds/>Remote QPU Credentials</a></li><li><a href=/deploy/users/tnqvm/>Tensor Network Quantum Virtual Machine</a></li><li><a href=/deploy/users/using_optimizer/>Using an Optimizer</a></li><li><a href=/deploy/users/variational/>Variational Algorithms</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>