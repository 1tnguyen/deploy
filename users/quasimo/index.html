<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Quantum Simulation Modeling (QuaSiMo) - AIDE-QC</title><meta name=description content="Advanced Integrated Development Environment for Quantum Computing"><meta name=generator content="Hugo 0.76.5"><link href=https://aide-qc.github.io/deployindex.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://aide-qc.github.io/deploy/users/quasimo/><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://aide-qc.github.io/deploy/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://aide-qc.github.io/deploy/aide_qc_logo_v3.png width=40px align=absmiddle>
AIDE-QC</div></h1><p class=description>Advanced Integrated Development Environment for Quantum Computing</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://aideqc.slack.com>AIDE-QC Slack</a></li><li class=child><a href=https://xacc-dev.slack.com>XACC/QCOR Slack</a></li></ul></li><li class=parent><a href=https://github.com/aide-qc>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://ornl-qci.github.io/qcor-api-docs/>QCOR Doxygen</a></li><li class=child><a href=https://ornl-qci.github.io/xacc-api-docs/>XACC Doxygen</a></li><li class=child><a href=https://github.com/aide-qc/qcor>QCOR</a></li><li class=child><a href=https://github.com/aide-qc/xacc>XACC</a></li></ul></li><li><a href=https://github.com/aide-qc/aide-qc/issues>Bugs</a></li><li><a href=http://aide-qc.org>Project Page</a></li></ul></nav></div><div class=content-container><main><h1>Quantum Simulation Modeling (QuaSiMo)</h1><h3 id=table-of-contents>Table of Contents&nbsp;<a class=headline-hash href=#table-of-contents>¶</a></h3><ul><li><a href=#overview>Overview</a></li><li><a href=#problem-model>Simulation Model</a></li><li><a href=#workflow>Workflow</a></li><li><a href=#cost-eval>Cost Function Evaluate</a></li><li><a href=#new-workflow>Implement a new workflow</a></li></ul><h2 id=a-idoverviewa-overview><a id=overview></a>Overview&nbsp;<a class=headline-hash href=#a-idoverviewa-overview>¶</a></h2><p>The QuaSiMo library provides domain-specific tools for quantum simulation on quantum computers. It supports problems such as ground-state energy computations or time-dependent simulations.</p><p>The library comprises the main drivers, so-called
<a href=#workflow>workflows</a>
(<code>QuantumSimulationWorkflow</code>), which encapsulate the procedure (classical and quantum routines) to solve the quantum simulation problem. The input to QuaSiMo&rsquo;s workflows is a
<a href=#problem-model><code>QuantumSimulationModel</code></a>
, specifying all the parameters of the quantum simulation problem, e.g., the observable operator, the Hamiltonian operator, which may be different from the observable or is time-dependent, etc.</p><p>The QuaSiMo library provides a <code>ModelFactory</code> factory to facilitate <code>QuantumSimulationModel</code> creation for common use cases.</p><p>Built-in workflows can be retrieved from the registry by using <code>getWorkflow</code> helper function with the corresponding workflow name, such as <code>vqe</code>, <code>qaoa</code>, <code>qite</code>, etc.</p><p>Some workflow may require additional configurations, which should be provided when calling <code>getWorkflow</code>. Please refer to specific workflow sections for information about their supported configurations.</p><p>The retrieved workflow instance can then be used to solve the <code>QuantumSimulationModel</code> problem using the <code>execute</code> method, which returns the result information specific to that workflow, such as the ground-state energy for variational quantum eigensolver workflow or the time-series expectation values for time-dependent quantum simulation.</p><p>For advanced users or workflow developers, the QuaSiMo library also provides interfaces for state-preparation (ansatz) circuit generation and cost function (observable) evaluator.</p><p>The first can be used during workflow execution to construct the quantum circuits for evaluation, e.g., variational circuits of a particular structure or first-order Trotter circuits for Hamiltonian evolution.</p><p>The latter provides an abstraction for quantum backend execution and post-processing actions to compute the expectation value of an observable operator. For example, the cost function evaluator may add necessary gates to change the basis according to the observable operators, analyze the bitstring result to extract the expectation value. For more information, please refer to the Cost Function Evaluate
<a href=#cost-eval>section</a>
.</p><h2 id=a-idproblem-modela-quantum-simulation-model><a id=problem-model></a>Quantum Simulation Model&nbsp;<a class=headline-hash href=#a-idproblem-modela-quantum-simulation-model>¶</a></h2><p>The input to all QuaSiMo workflows is a <code>QuantumSimulationModel</code>, which can be generated by the <code>createModel</code> method from the <code>ModelFactory</code> factory. There are a couple of <code>createModel</code> overloads.</p><p>At the minimum, the problem model contains information about the target observable whose expectation value is the optimization objective of the workflow. The observable is constructed as a QCOR
<a href=../operators>operator</a>
. For example,</p><ul><li>In C++:</li></ul><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// Create the Deuteron Hamiltonian
</span><span class=c1></span><span class=k>auto</span> <span class=n>H</span> <span class=o>=</span> <span class=mf>5.907</span> <span class=o>-</span> <span class=mf>2.1433</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mf>2.143</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mf>0.21829</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>-</span>
          <span class=mf>6.125</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
<span class=k>auto</span> <span class=n>problemModel</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>::</span><span class=n>ModelFactory</span><span class=o>::</span><span class=n>createModel</span><span class=p>(</span><span class=n>H</span><span class=p>);</span>
</code></pre></div><ul><li>In Python:</li></ul><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># Define the deuteron hamiltonian </span>
<span class=n>H</span> <span class=o>=</span> <span class=o>-</span><span class=mf>2.1433</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mf>2.1433</span> <span class=o>*</span> \
    <span class=n>Y</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=o>.</span><span class=mi>21829</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>-</span> <span class=mf>6.125</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mf>5.907</span>

<span class=n>problemModel</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>.</span><span class=n>ModelFactory</span><span class=o>.</span><span class=n>createModel</span><span class=p>(</span><span class=n>H</span><span class=p>)</span>
</code></pre></div><p>If a specific state-preparation ansatz circuit is to be used, a QCOR kernel function can also be provided to the <code>createModel</code> method as follows,</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># Define the deuteron hamiltonian </span>
<span class=n>H</span> <span class=o>=</span> <span class=o>-</span><span class=mf>2.1433</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mf>2.1433</span> <span class=o>*</span> \
    <span class=n>Y</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=o>.</span><span class=mi>21829</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>-</span> <span class=mf>6.125</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mf>5.907</span>

<span class=c1># Define the quantum kernel</span>
<span class=nd>@qjit</span>
<span class=k>def</span> <span class=nf>ansatz</span><span class=p>(</span><span class=n>q</span> <span class=p>:</span> <span class=n>qreg</span><span class=p>,</span> <span class=n>theta</span> <span class=p>:</span> <span class=nb>float</span><span class=p>):</span>
    <span class=n>X</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=n>Ry</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>theta</span><span class=p>)</span>
    <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>

<span class=c1># Create the problem model, provide the state </span>
<span class=c1># prep circuit, Hamiltonian and note how many qubits</span>
<span class=c1># and variational parameters </span>
<span class=n>num_params</span> <span class=o>=</span> <span class=mi>1</span>
<span class=n>problemModel</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>.</span><span class=n>ModelFactory</span><span class=o>.</span><span class=n>createModel</span><span class=p>(</span><span class=n>ansatz</span><span class=p>,</span> <span class=n>H</span><span class=p>,</span> <span class=n>num_params</span><span class=p>)</span>
</code></pre></div><p>The above example is for Python. C++ API is completely identical and is shown in the
<a href=#vqe-workflow>VQE</a>
section below.</p><p>When the Hamiltonian operator is different from the observable operator, e.g. for systems with time-dependent Hamiltonian, users can provide this Hamiltonian as a function from time value to concrete operator value. Noted that a static Hamiltonian can be returned if the system is time-independent. Please refer to the
<a href=#td-ham-workflow>time-dependent simulation</a>
section for examples.</p><h2 id=a-idworkflowa-workflow><a id=workflow></a>Workflow&nbsp;<a class=headline-hash href=#a-idworkflowa-workflow>¶</a></h2><p>The QuaSiMo library has built-in implementations for Variational Quantum Eigensolver algorithm (VQE), Quantum Approximate Optimization Algorithm (QAOA), Quantum Imaginary Time Evolution (QITE), and general time-dependent evolution workflows. Here, we show simple examples for common use cases and explain extra configuration parameters that each workflow may take.</p><h3 id=a-idvqe-workflowa-variational-quantum-eigensolver---vqe><a id=vqe-workflow></a>Variational Quantum Eigensolver - VQE&nbsp;<a class=headline-hash href=#a-idvqe-workflowa-variational-quantum-eigensolver---vqe>¶</a></h3><p>A Variational Quantum Eigensolver algorithm workflow instance can be retrieved from the QuaSiMo registry by calling <code>getWorkflow("vqe")</code> as shown in the below example.</p><table><tr><th>Deuteron VQE - C++</th><th>Deuteron VQE - Python</th></tr><tr><td><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&#34;qcor_qsim.hpp&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=c1>// Define a fixed ansatz as a QCOR kernel
</span><span class=c1></span><span class=n>__qpu__</span> <span class=kt>void</span> <span class=nf>ansatz</span><span class=p>(</span><span class=n>qreg</span> <span class=n>q</span><span class=p>,</span> <span class=kt>double</span> <span class=n>theta</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>X</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
  <span class=k>auto</span> <span class=n>exponent_op</span> <span class=o>=</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=n>Y</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
  <span class=n>exp_i_theta</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=n>theta</span><span class=p>,</span> <span class=n>exponent_op</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Create the Deuteron Hamiltonian
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>H</span> <span class=o>=</span> <span class=mf>5.907</span> <span class=o>-</span> <span class=mf>2.1433</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mf>2.143</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mf>0.21829</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>-</span>
           <span class=mf>6.125</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
  <span class=k>const</span> <span class=k>auto</span> <span class=n>num_qubits</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
  <span class=k>const</span> <span class=k>auto</span> <span class=n>num_params</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
  <span class=k>auto</span> <span class=n>problemModel</span> <span class=o>=</span>
      <span class=n>QuaSiMo</span><span class=o>::</span><span class=n>ModelFactory</span><span class=o>::</span><span class=n>createModel</span><span class=p>(</span><span class=n>ansatz</span><span class=p>,</span> <span class=n>H</span><span class=p>,</span> <span class=n>num_qubits</span><span class=p>,</span> <span class=n>num_params</span><span class=p>);</span>
  <span class=k>auto</span> <span class=n>optimizer</span> <span class=o>=</span> <span class=n>createOptimizer</span><span class=p>(</span><span class=s>&#34;nlopt&#34;</span><span class=p>);</span>
  <span class=c1>// Instantiate a VQE workflow with the nlopt optimizer
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>workflow</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>::</span><span class=n>getWorkflow</span><span class=p>(</span><span class=s>&#34;vqe&#34;</span><span class=p>,</span> <span class=p>{{</span><span class=s>&#34;optimizer&#34;</span><span class=p>,</span> <span class=n>optimizer</span><span class=p>}});</span>

  <span class=c1>// Result should contain the ground-state energy along with the optimal
</span><span class=c1></span>  <span class=c1>// parameters.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>workflow</span><span class=o>-&gt;</span><span class=n>execute</span><span class=p>(</span><span class=n>problemModel</span><span class=p>);</span>

  <span class=k>const</span> <span class=k>auto</span> <span class=n>energy</span> <span class=o>=</span> <span class=n>result</span><span class=p>.</span><span class=n>get</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;energy&#34;</span><span class=p>);</span>
  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Ground-state energy = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>energy</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></td><td><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=o>*</span> 

<span class=c1># Define the deuteron hamiltonian </span>
<span class=n>H</span> <span class=o>=</span> <span class=o>-</span><span class=mf>2.1433</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mf>2.1433</span> <span class=o>*</span> \
    <span class=n>Y</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=o>.</span><span class=mi>21829</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>-</span> <span class=mf>6.125</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mf>5.907</span>

<span class=c1># Define the quantum kernel by providing a </span>
<span class=c1># python function that is annotated with qjit for </span>
<span class=c1># quantum just in time compilation</span>
<span class=nd>@qjit</span>
<span class=k>def</span> <span class=nf>ansatz</span><span class=p>(</span><span class=n>q</span> <span class=p>:</span> <span class=n>qreg</span><span class=p>,</span> <span class=n>theta</span> <span class=p>:</span> <span class=nb>float</span><span class=p>):</span>
    <span class=n>X</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=n>Ry</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>theta</span><span class=p>)</span>
    <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>

<span class=c1># Create the problem model, provide the state </span>
<span class=c1># prep circuit, Hamiltonian and note how many qubits</span>
<span class=c1># and variational parameters </span>
<span class=n>num_params</span> <span class=o>=</span> <span class=mi>1</span>
<span class=n>problemModel</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>.</span><span class=n>ModelFactory</span><span class=o>.</span><span class=n>createModel</span><span class=p>(</span><span class=n>ansatz</span><span class=p>,</span> <span class=n>H</span><span class=p>,</span> <span class=n>num_params</span><span class=p>)</span>
      
<span class=c1># Create the NLOpt derivative free optimizer</span>
<span class=n>optimizer</span> <span class=o>=</span> <span class=n>createOptimizer</span><span class=p>(</span><span class=s1>&#39;nlopt&#39;</span><span class=p>)</span>

<span class=c1># Create the VQE workflow</span>
<span class=n>workflow</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>.</span><span class=n>getWorkflow</span><span class=p>(</span><span class=s1>&#39;vqe&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;optimizer&#39;</span><span class=p>:</span> <span class=n>optimizer</span><span class=p>})</span>

<span class=c1># Execute and print the result</span>
<span class=n>result</span> <span class=o>=</span> <span class=n>workflow</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>problemModel</span><span class=p>)</span>
<span class=n>energy</span> <span class=o>=</span> <span class=n>result</span><span class=p>[</span><span class=s1>&#39;energy&#39;</span><span class=p>]</span>
<span class=k>print</span><span class=p>(</span><span class=n>energy</span><span class=p>)</span>
</code></pre></div></td></tr></table><p>As we may see, users can provide a specific optimizer instance to the VQE workflow to be used. By default, the <code>nlopt</code>(gradient-free) optimizer will be used if none is provided.</p><p>VQE workflow returns the following information:</p><table><thead><tr><th>Result Key</th><th>Description</th></tr></thead><tbody><tr><td><code>energy</code></td><td>The final (optimized) energy (observable expectation value).</td></tr><tr><td><code>opt-params</code></td><td>The list of optimized variational parameters.</td></tr></tbody></table><h3 id=a-idqaoa-workflowa-quantum-approximate-optimization-algorithm---qaoa><a id=qaoa-workflow></a>Quantum Approximate Optimization Algorithm - QAOA&nbsp;<a class=headline-hash href=#a-idqaoa-workflowa-quantum-approximate-optimization-algorithm---qaoa>¶</a></h3><p>The Quantum Approximate Optimization Algorithm (QAOA) workflow has the following configuration parameters:</p><table><thead><tr><th>Param Key</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>optimizer</code></td><td>The classical optimizer.</td><td><code>nlopt</code></td></tr><tr><td><code>steps</code></td><td>The integer parameter p as specified
<a href=https://arxiv.org/abs/1411.4028>here</a>
.</td><td>1</td></tr><tr><td><code>parameter-scheme</code></td><td><code>Standard</code> or <code>Extended</code> parameterization scheme. In the <code>Extended</code> scheme, all rotation angles are considered as independent variational parameters.</td><td><code>Standard</code></td></tr><tr><td><code>gradient-strategy</code></td><td>The gradient strategy to be used if the optimizer is gradient-based.</td><td><code>autodiff</code></td></tr></tbody></table><p>A simple QAOA workflow execution is shown in the below example.</p><table><tr><th>Deuteron QAOA - C++</th><th>Deuteron QAOA - Python</th></tr><tr><td><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&#34;qcor_qsim.hpp&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Create the Deuteron Hamiltonian
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>H</span> <span class=o>=</span> <span class=mf>5.907</span> <span class=o>-</span> <span class=mf>2.1433</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mf>2.143</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mf>0.21829</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>-</span>
           <span class=mf>6.125</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
  <span class=k>auto</span> <span class=n>problemModel</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>::</span><span class=n>ModelFactory</span><span class=o>::</span><span class=n>createModel</span><span class=p>(</span><span class=n>H</span><span class=p>);</span>
  <span class=k>auto</span> <span class=n>optimizer</span> <span class=o>=</span> <span class=n>createOptimizer</span><span class=p>(</span><span class=s>&#34;nlopt&#34;</span><span class=p>);</span>
  <span class=c1>// Instantiate a QAOA workflow with the nlopt optimizer
</span><span class=c1></span>  <span class=c1>// &#34;steps&#34; = the (p) param in QAOA algorithm.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>workflow</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>::</span><span class=n>getWorkflow</span><span class=p>(</span><span class=s>&#34;qaoa&#34;</span><span class=p>,</span> <span class=p>{{</span><span class=s>&#34;optimizer&#34;</span><span class=p>,</span> <span class=n>optimizer</span><span class=p>},</span> <span class=p>{</span><span class=s>&#34;steps&#34;</span><span class=p>,</span> <span class=mi>8</span><span class=p>}});</span>

  <span class=c1>// Result should contain the ground-state energy along with the optimal
</span><span class=c1></span>  <span class=c1>// parameters.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>workflow</span><span class=o>-&gt;</span><span class=n>execute</span><span class=p>(</span><span class=n>problemModel</span><span class=p>);</span>

  <span class=k>const</span> <span class=k>auto</span> <span class=n>energy</span> <span class=o>=</span> <span class=n>result</span><span class=p>.</span><span class=n>get</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;energy&#34;</span><span class=p>);</span>
  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Ground-state energy = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>energy</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></td><td><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=o>*</span> 

<span class=c1># Solving deuteron problem using QuaSiMo QAOA</span>

<span class=c1># Define the deuteron hamiltonian </span>
<span class=n>H</span> <span class=o>=</span> <span class=o>-</span><span class=mf>2.1433</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mf>2.1433</span> <span class=o>*</span> \
    <span class=n>Y</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=o>.</span><span class=mi>21829</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>-</span> <span class=mf>6.125</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mf>5.907</span>

<span class=n>problemModel</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>.</span><span class=n>ModelFactory</span><span class=o>.</span><span class=n>createModel</span><span class=p>(</span><span class=n>H</span><span class=p>)</span>
      
<span class=c1># Create the NLOpt derivative free optimizer</span>
<span class=n>optimizer</span> <span class=o>=</span> <span class=n>createOptimizer</span><span class=p>(</span><span class=s1>&#39;nlopt&#39;</span><span class=p>)</span>

<span class=c1># Create the QAOA workflow with p = 8 steps</span>
<span class=n>workflow</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>.</span><span class=n>getWorkflow</span><span class=p>(</span><span class=s1>&#39;qaoa&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;optimizer&#39;</span><span class=p>:</span> <span class=n>optimizer</span><span class=p>,</span> <span class=s1>&#39;steps&#39;</span><span class=p>:</span> <span class=mi>8</span><span class=p>})</span>

<span class=c1># Execute and print the result</span>
<span class=n>result</span> <span class=o>=</span> <span class=n>workflow</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>problemModel</span><span class=p>)</span>
<span class=n>energy</span> <span class=o>=</span> <span class=n>result</span><span class=p>[</span><span class=s1>&#39;energy&#39;</span><span class=p>]</span>
<span class=k>print</span><span class=p>(</span><span class=n>energy</span><span class=p>)</span>
</code></pre></div></td></tr></table><p>QAOA workflow returns the following information:</p><table><thead><tr><th>Result Key</th><th>Description</th></tr></thead><tbody><tr><td><code>energy</code></td><td>The final (optimized) energy (observable expectation value).</td></tr><tr><td><code>opt-params</code></td><td>The list of optimized QAOA parameters (depending on the parameterization scheme).</td></tr></tbody></table><h3 id=a-idqite-workflowa-quantum-imaginary-time-evolution---qite><a id=qite-workflow></a>Quantum Imaginary Time Evolution - QITE&nbsp;<a class=headline-hash href=#a-idqite-workflowa-quantum-imaginary-time-evolution---qite>¶</a></h3><p>The Quantum Imaginary Time Evolution (QITE) workflow <strong>requires</strong> the following configuration parameters:</p><table><thead><tr><th>Param Key</th><th>Description</th></tr></thead><tbody><tr><td><code>step-size</code></td><td>The imaginary time step.</td></tr><tr><td><code>steps</code></td><td>The number of time steps to evolve the system in imaginary time.</td></tr></tbody></table><p>Below is a simple example of using the QITE workflow.</p><table><tr><th>QITE - C++</th><th>QITE - Python</th></tr><tr><td><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&#34;qcor_qsim.hpp&#34;</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>auto</span> <span class=n>ham</span> <span class=o>=</span> <span class=mf>0.7071067811865475</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=mf>0.7071067811865475</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
  <span class=c1>// Number of QITE time steps and step size
</span><span class=c1></span>  <span class=k>const</span> <span class=kt>int</span> <span class=n>nbSteps</span> <span class=o>=</span> <span class=mi>25</span><span class=p>;</span>
  <span class=k>const</span> <span class=kt>double</span> <span class=n>stepSize</span> <span class=o>=</span> <span class=mf>0.1</span><span class=p>;</span>
  <span class=k>auto</span> <span class=n>problemModel</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>::</span><span class=n>ModelFactory</span><span class=o>::</span><span class=n>createModel</span><span class=p>(</span><span class=n>ham</span><span class=p>);</span>
  <span class=k>auto</span> <span class=n>workflow</span> <span class=o>=</span>
      <span class=n>QuaSiMo</span><span class=o>::</span><span class=n>getWorkflow</span><span class=p>(</span><span class=s>&#34;qite&#34;</span><span class=p>,</span> <span class=p>{{</span><span class=s>&#34;steps&#34;</span><span class=p>,</span> <span class=n>nbSteps</span><span class=p>},</span> <span class=p>{</span><span class=s>&#34;step-size&#34;</span><span class=p>,</span> <span class=n>stepSize</span><span class=p>}});</span>
  <span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>workflow</span><span class=o>-&gt;</span><span class=n>execute</span><span class=p>(</span><span class=n>problemModel</span><span class=p>);</span>
  <span class=k>const</span> <span class=k>auto</span> <span class=n>energy</span> <span class=o>=</span> <span class=n>result</span><span class=p>.</span><span class=n>get</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;energy&#34;</span><span class=p>);</span>
  <span class=c1>// Array of energy values at each QITE step
</span><span class=c1></span>  <span class=k>const</span> <span class=k>auto</span> <span class=n>energyAtStep</span> <span class=o>=</span> <span class=n>result</span><span class=p>.</span><span class=n>get</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=s>&#34;exp-vals&#34;</span><span class=p>);</span>
  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Ground state energy: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>energy</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></td><td><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=o>*</span> 

<span class=c1># Target H = 1/sqrt(2)(X + Z)</span>
<span class=n>H</span> <span class=o>=</span> <span class=mf>0.7071067811865475</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=mf>0.7071067811865475</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>

<span class=c1># The number of Trotter steps </span>
<span class=n>nbSteps</span> <span class=o>=</span> <span class=mi>25</span>

<span class=c1># The Trotter step size</span>
<span class=n>stepSize</span> <span class=o>=</span> <span class=mf>0.1</span>

<span class=c1># Create the problem model</span>
<span class=n>problemModel</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>.</span><span class=n>ModelFactory</span><span class=o>.</span><span class=n>createModel</span><span class=p>(</span><span class=n>H</span><span class=p>)</span>

<span class=c1># Create the QITE workflow</span>
<span class=n>workflow</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>.</span><span class=n>getWorkflow</span><span class=p>(</span><span class=s1>&#39;qite&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;steps&#39;</span><span class=p>:</span> <span class=n>nbSteps</span><span class=p>,</span> <span class=s1>&#39;step-size&#39;</span><span class=p>:</span> <span class=n>stepSize</span><span class=p>})</span>

<span class=c1># Execute and print the result</span>
<span class=n>result</span> <span class=o>=</span> <span class=n>workflow</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>problemModel</span><span class=p>)</span>

<span class=c1># Final energy:</span>
<span class=n>energy</span> <span class=o>=</span> <span class=n>result</span><span class=p>[</span><span class=s1>&#39;energy&#39;</span><span class=p>]</span>
<span class=k>print</span><span class=p>(</span><span class=s1>&#39;Ground state energy =&#39;</span><span class=p>,</span> <span class=n>energy</span><span class=p>)</span>

<span class=c1># Energy values along QITE steps</span>
<span class=n>td_energy_vals</span> <span class=o>=</span> <span class=n>result</span><span class=p>[</span><span class=s1>&#39;exp-vals&#39;</span><span class=p>]</span>
<span class=k>print</span><span class=p>(</span><span class=n>td_energy_vals</span><span class=p>)</span>
</code></pre></div></td></tr></table><p>QITE workflow returns the following information:</p><table><thead><tr><th>Result Key</th><th>Description</th></tr></thead><tbody><tr><td><code>energy</code></td><td>The final energy at the end of the QITE time-stepping.</td></tr><tr><td><code>exp-vals</code></td><td>QITE time-stepping expectation value data.</td></tr><tr><td><code>circuit</code></td><td>The complete QITE circuit.</td></tr></tbody></table><h3 id=a-idtd-ham-workflowa-time-dependent-simulation><a id=td-ham-workflow></a>Time-dependent Simulation&nbsp;<a class=headline-hash href=#a-idtd-ham-workflowa-time-dependent-simulation>¶</a></h3><p>The time-dependent simulation (<code>td-evolution</code>) workflow <strong>requires</strong> the following configuration parameters:</p><table><thead><tr><th>Param Key</th><th>Description</th></tr></thead><tbody><tr><td><code>dt</code></td><td>The Trotter time step.</td></tr><tr><td><code>steps</code></td><td>The number of time steps to evolve the system.</td></tr></tbody></table><p>To execute a time-dependent simulation workflow, the problem model should provide a Hamiltonian function<br>taking time value as the input and returning the Hamiltonian operator.</p><p>This is illustrated in the below example.</p><table><tr><th>Time-dependent - C++</th><th>Time-dependent - Python</th></tr><tr><td><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&#34;qcor_qsim.hpp&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Time-dependent Hamiltonian
</span><span class=c1></span>  <span class=n>QuaSiMo</span><span class=o>::</span><span class=n>TdObservable</span> <span class=n>H</span> <span class=o>=</span> <span class=p>[](</span><span class=kt>double</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Parameters:
</span><span class=c1></span>    <span class=k>const</span> <span class=kt>double</span> <span class=n>Jz</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>M_PI</span> <span class=o>*</span> <span class=mf>2.86265</span> <span class=o>*</span> <span class=mf>1e-3</span><span class=p>;</span>
    <span class=k>const</span> <span class=kt>double</span> <span class=n>epsilon</span> <span class=o>=</span> <span class=n>Jz</span><span class=p>;</span> 
    <span class=k>const</span> <span class=kt>double</span> <span class=n>omega</span> <span class=o>=</span> <span class=mf>4.8</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>M_PI</span> <span class=o>*</span> <span class=mf>1e-3</span><span class=p>;</span>
    <span class=k>return</span> <span class=o>-</span><span class=n>Jz</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=n>Jz</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>-</span>
           <span class=n>epsilon</span> <span class=o>*</span> <span class=n>std</span><span class=o>::</span><span class=n>cos</span><span class=p>(</span><span class=n>omega</span> <span class=o>*</span> <span class=n>t</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>X</span><span class=p>(</span><span class=mi>2</span><span class=p>));</span>
  <span class=p>};</span>

  <span class=c1>// Observable = average magnetization
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>observable</span> <span class=o>=</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>/</span> <span class=mf>3.0</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>Z</span><span class=p>(</span><span class=mi>2</span><span class=p>));</span>

  <span class=c1>// Example: build model and TD workflow 
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>problemModel</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>::</span><span class=n>ModelFactory</span><span class=o>::</span><span class=n>createModel</span><span class=p>(</span><span class=n>observable</span><span class=p>,</span> <span class=n>H</span><span class=p>);</span>
  <span class=c1>// Trotter step = 3fs, number of steps = 100 -&gt; end time = 300fs
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>workflow</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>::</span><span class=n>getWorkflow</span><span class=p>(</span>
      <span class=s>&#34;td-evolution&#34;</span><span class=p>,</span> <span class=p>{{</span><span class=s>&#34;dt&#34;</span><span class=p>,</span> <span class=mf>3.0</span><span class=p>},</span> <span class=p>{</span><span class=s>&#34;steps&#34;</span><span class=p>,</span> <span class=mi>100</span><span class=p>}});</span>

  <span class=c1>// Result should contain the observable expectation value along Trotter steps.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>workflow</span><span class=o>-&gt;</span><span class=n>execute</span><span class=p>(</span><span class=n>problemModel</span><span class=p>);</span>
  <span class=c1>// Get the observable values (average magnetization)
</span><span class=c1></span>  <span class=k>const</span> <span class=k>auto</span> <span class=n>obsVals</span> <span class=o>=</span> <span class=n>result</span><span class=p>.</span><span class=n>get</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=s>&#34;exp-vals&#34;</span><span class=p>);</span>

  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>

</code></pre></div></td><td><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=o>*</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># Time-dependent Hamiltonian: </span>
<span class=c1># Returns the Pauli operators at a time point.</span>
<span class=k>def</span> <span class=nf>td_hamiltonian</span><span class=p>(</span><span class=n>t</span><span class=p>):</span>
  <span class=n>Jz</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=mf>2.86265</span> <span class=o>*</span> <span class=mf>1e-3</span>
  <span class=n>epsilon</span> <span class=o>=</span> <span class=n>Jz</span>
  <span class=n>omega</span> <span class=o>=</span> <span class=mf>4.8</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=mf>1e-3</span>
  <span class=k>return</span> <span class=o>-</span><span class=n>Jz</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=o>-</span> <span class=n>Jz</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=o>-</span><span class=n>epsilon</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>cos</span><span class=p>(</span><span class=n>omega</span> <span class=o>*</span> <span class=n>t</span><span class=p>))</span> <span class=o>*</span> <span class=p>(</span><span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>X</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span> 

<span class=c1># Observable = average magnetization</span>
<span class=n>observable</span> <span class=o>=</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>/</span> <span class=mf>3.0</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>Z</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span>

<span class=c1># Build model and TD workflow </span>
<span class=n>problemModel</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>.</span><span class=n>ModelFactory</span><span class=o>.</span><span class=n>createModel</span><span class=p>(</span><span class=n>observable</span><span class=p>,</span> <span class=n>td_hamiltonian</span><span class=p>)</span>
<span class=c1># TD workflow with hyper-parameters: </span>
<span class=c1># Trotter step = 3fs, number of steps = 100 -&gt; end time = 300fs</span>
<span class=n>workflow</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>.</span><span class=n>getWorkflow</span><span class=p>(</span>
      <span class=s2>&#34;td-evolution&#34;</span><span class=p>,</span> <span class=p>{</span><span class=s2>&#34;dt&#34;</span><span class=p>:</span> <span class=mf>3.0</span><span class=p>,</span> <span class=s2>&#34;steps&#34;</span><span class=p>:</span> <span class=mi>100</span><span class=p>})</span>

<span class=c1># Result contains the observable expectation value along Trotter steps.</span>
<span class=n>result</span> <span class=o>=</span> <span class=n>workflow</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>problemModel</span><span class=p>)</span>
<span class=n>obsVals</span> <span class=o>=</span> <span class=n>result</span><span class=p>[</span><span class=s2>&#34;exp-vals&#34;</span><span class=p>]</span>
<span class=k>print</span><span class=p>(</span><span class=n>obsVals</span><span class=p>)</span>
</code></pre></div></td></tr></table><p>Time-dependent simulation workflow returns the following information:</p><table><thead><tr><th>Result Key</th><th>Description</th></tr></thead><tbody><tr><td><code>exp-vals</code></td><td>The time-stepping expectation value data.</td></tr></tbody></table><h2 id=a-idcost-evala-cost-function-observable-evaluate><a id=cost-eval></a>Cost Function (Observable) Evaluate&nbsp;<a class=headline-hash href=#a-idcost-evala-cost-function-observable-evaluate>¶</a></h2><p>A common utility that is required across QuaSiMo workflows is the ability to <em>observe</em> the expectation value of an arbitrary operator at a specific quantum state (e.g., after the ansatz circuit or after a certain number of Trotter steps).</p><p>This capability is provided by the <code>CostFunctionEvaluator</code> interface in the QuaSiMo library.</p><p>There are two <code>CostFunctionEvaluator</code> implementations currently available: the <code>default</code> one, which is based on the partial tomography method, and the quantum phase estimation (<code>qpe</code>)-based method, which can be optionally error-mitigated via the protocol described in this
<a href=https://arxiv.org/pdf/2010.02538.pdf>paper</a>
.</p><p>All workflows accept an optional <code>evaluator</code> key in addition to their set of configuration parameters to specify the <code>CostFunctionEvaluator</code> (via a name string or an instantiated instance). If none provided, the partial-tomography (<code>default</code>) one will be used.</p><p>The <code>CostFunctionEvaluator</code> configuration parameters, if any, can be provided in the workflow parameter pack, which will be forwarded to the <code>CostFunctionEvaluator</code> appropriately.</p><p>The <code>CostFunctionEvaluator</code> will use the runtime QPU instance to execute the necessary sub-circuits to evaluate the operator expectation value.</p><h3 id=a-idpartial-tomoa-partial-tomography><a id=partial-tomo></a>Partial Tomography&nbsp;<a class=headline-hash href=#a-idpartial-tomoa-partial-tomography>¶</a></h3><p>The <code>default</code> CostFunctionEvaluator is based on the partial tomography method, whereby change-of-basis gates are added to measure the expectation values of each product term in the operator.</p><p>Users don&rsquo;t need to provide the <code>evaluator</code> key (and set it to <code>default</code>) when creating the workflow if they wish to use this method because all workflows assume this option.</p><p>It&rsquo;s worth noting that error mitigation (if any) for this cost evaluator is performed at the QPU level via conventional QCOR error mitigation decorators.</p><h3 id=a-idphase-esta-quantum-phase-estimation><a id=phase-est></a>Quantum Phase Estimation&nbsp;<a class=headline-hash href=#a-idphase-esta-quantum-phase-estimation>¶</a></h3><p>The <code>qpe</code> cost evaluator is based on the time-series quantum phase estimation method to estimate the expectation value. In particular, it makes use of the
<a href=https://en.wikipedia.org/wiki/Prony%27s_method>Prony</a>
signal processing method to extract the expectation value estimate from the time-series QPE signal.</p><p>The <code>qpe</code> cost evaluator has the following configuration parameters:</p><table><thead><tr><th>Param Key</th><th>Description</th></tr></thead><tbody><tr><td><code>steps</code></td><td>The number of data points for classical signal processing. Default is 5, which is the minimum number of samples to estimate the energy of two-eigenvalue operators.</td></tr><tr><td><code>verified</code></td><td>(True/False) If true, it will run the verified phase estimation protocol as described in this
<a href=https://arxiv.org/pdf/2010.02538.pdf>paper</a>
.</td></tr></tbody></table><p>The <code>qpe</code> cost evaluator can be explicitly instantiated by using the <code>getObjEvaluator</code> helper function and providing the<br>operator to be evaluated, the name key (<code>qpe</code>), and any additional parameters.</p><p>For example,</p><ul><li>In C++:</li></ul><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>auto</span> <span class=n>observable</span> <span class=o>=</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>Z</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
<span class=k>auto</span> <span class=n>vqpeEvaluator</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>::</span><span class=n>getObjEvaluator</span><span class=p>(</span><span class=n>observable</span><span class=p>,</span> <span class=s>&#34;qpe&#34;</span><span class=p>,</span> <span class=p>{{</span><span class=s>&#34;verified&#34;</span><span class=p>,</span> <span class=nb>true</span><span class=p>}});</span>
</code></pre></div><ul><li>In Python:</li></ul><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>observable</span> <span class=o>=</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>Z</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
<span class=n>vqpeEvaluator</span> <span class=o>=</span> <span class=n>QuaSiMo</span><span class=o>.</span><span class=n>getObjEvaluator</span><span class=p>(</span><span class=n>observable</span><span class=p>,</span> <span class=s1>&#39;qpe&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;verified&#39;</span><span class=p>:</span> <span class=bp>True</span><span class=p>})</span>
</code></pre></div><h2 id=a-idnew-workflowa-implement-a-new-workflow><a id=new-workflow></a>Implement a new workflow&nbsp;<a class=headline-hash href=#a-idnew-workflowa-implement-a-new-workflow>¶</a></h2><p>Please refer to this
<a href=/deploy/developers/implement_quasimo_workflow/>section</a>
for a tutorial on how to create a new QuaSiMo workflow plugin.</p><div class=edit-meta><br><a href=https://github.com/aide-qc/deploy//edit/master/website/content/users/quasimo.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/deploy/users/quantum_kernels/ title="Quantum Kernels"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Quantum Kernels</a>
<a class="nav nav-next" href=/deploy/users/remote_qpu_creds/ title="Remote QPU Credentials">Next - Remote QPU Credentials <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://aide-qc.github.io/deploy>Home</a></li><li class=has-sub-menu><a href=/deploy/background/>Background<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/background/qcor/>QCOR C++ Compiler and JIT Engine</a></li><li><a href=/deploy/background/xacc/>XACC Quantum Programming Framework</a></li><li><a href=/deploy/background/project/></a></li></ul></li><li class=has-sub-menu><a href=/deploy/developers/>Developer Guide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/developers/implement_circuit_synthesis/>Add a New Circuit Synthesis Strategy</a></li><li><a href=/deploy/developers/implement_optimizer/>Add a New Optimizer</a></li><li><a href=/deploy/developers/implement_accelerator/>Add a New Quantum Backend</a></li><li><a href=/deploy/developers/implement_quasimo_workflow/>Add a New QuaSiMo Workflow</a></li><li><a href=/deploy/developers/implement_plugin_embedded_python/>Hybrid C++ / Python Plugins</a></li><li><a href=/deploy/developers/clang_syntax/></a></li></ul></li><li class=has-sub-menu><a href=/deploy/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/getting_started/Faq/>Frequently Asked Questions</a></li><li><a href=/deploy/getting_started/build_from_source/>Build Everything from Source</a></li></ul></li><li class=has-sub-menu><a href=/deploy/lang_spec/>QCOR Classical Language Extension<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/lang_spec/data_model/>Data Model</a></li><li><a href=/deploy/lang_spec/exec_model/>Execution Model</a></li><li><a href=/deploy/lang_spec/memory/>Memory Model</a></li><li><a href=/deploy/lang_spec/prog_model/>Programming Model</a></li></ul></li><li class="parent has-sub-menu"><a href=/deploy/users/>User Guide<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/deploy/developers/implement_circuit_synthesis/>Add a New Circuit Synthesis Strategy</a></li><li><a href=/deploy/developers/implement_optimizer/>Add a New Optimizer</a></li><li><a href=/deploy/developers/implement_accelerator/>Add a New Quantum Backend</a></li><li><a href=/deploy/developers/implement_quasimo_workflow/>Add a New QuaSiMo Workflow</a></li><li><a href=/deploy/developers/implement_plugin_embedded_python/>Hybrid C++ / Python Plugins</a></li><li><a href=/deploy/developers/clang_syntax/></a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>