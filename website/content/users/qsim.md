---
title: "Quantum Simulation (QSim)"
date: 2019-11-29T15:26:15Z
draft: false
weight: 15
---

### Table of Contents
* [Overview](#overview)
* [Simulation Model](#problem-model)
* [Workflow](#workflow)
* [Cost Function Evaluate](#cost-eval)
* [Implement a new workflow](#new-workflow)

## <a id="overview"></a> Overview 

The QSim library provides domain-specific tools for quantum simulation on quantum computers. It supports problems such as ground-state energy computations or time-dependent simulations.

The library comprises the main drivers, so-called [workflows](#workflow) (`QuantumSimulationWorkflow`), which encapsulate the procedure (classical and quantum routines) to solve the quantum simulation problem. The input to QSim's workflows is a [`QuantumSimulationModel`](#problem-model), specifying all the parameters of the quantum simulation problem, e.g., the observable operator, the Hamiltonian operator, which may be different from the observable or is time-dependent, etc.

The QSim library provides a `ModelBuilder` factory to facilitate `QuantumSimulationModel` creation for common use cases.

Built-in workflows can be retrieved from the registry by using `getWorkflow` helper function with the corresponding workflow name, such as `vqe`, `qaoa`, `qite`, etc. 

Some workflow may require additional configurations, which should be provided when calling `getWorkflow`. Please refer to specific workflow sections for information about their supported configurations. 

The retrieved workflow instance can then be used to solve the `QuantumSimulationModel` problem using the `execute` method, which returns the result information specific to that workflow, such as the ground-state energy for variational quantum eigensolver workflow or the time-series expectation values for time-dependent quantum simulation.

For advanced users or workflow developers, the QSim library also provides interfaces for state-preparation (ansatz) circuit generation and cost function (observable) evaluator. 

The first can be used during workflow execution to construct the quantum circuits for evaluation, e.g., variational circuits of a particular structure or first-order Trotter circuits for Hamiltonian evolution. 

The latter provides an abstraction for quantum backend execution and post-processing actions to compute the expectation value of an observable operator. For example, the cost function evaluator may add necessary gates to change the basis according to the observable operators, analyze the bitstring result to extract the expectation value. For more information, please refer to the Cost Function Evaluate [section](#cost-eval).

## <a id="problem-model"></a> Quantum Simulation Model 

The input to all Qsim workflows is a `QuantumSimulationModel`, which can be generated by the `createModel` method from the `ModelBuilder` factory. There are a couple of `createModel` overloads.

At the minimum, the problem model contains information about the target observable whose expectation value is the optimization objective of the workflow. The observable is constructed as a QCOR [operator](../operators). For example,

- In C++:

```cpp
// Create the Deuteron Hamiltonian
auto H = 5.907 - 2.1433 * X(0) * X(1) - 2.143 * Y(0) * Y(1) + 0.21829 * Z(0) -
          6.125 * Z(1);
auto problemModel = qsim::ModelBuilder::createModel(H);
```

- In Python:

```python
# Define the deuteron hamiltonian 
H = -2.1433 * X(0) * X(1) - 2.1433 * \
    Y(0) * Y(1) + .21829 * Z(0) - 6.125 * Z(1) + 5.907

problemModel = qsim.ModelBuilder.createModel(H)
```

If a specific state-preparation ansatz circuit is to be used, a QCOR kernel function can also be provided to the `createModel` method as follows,

```python
# Define the deuteron hamiltonian 
H = -2.1433 * X(0) * X(1) - 2.1433 * \
    Y(0) * Y(1) + .21829 * Z(0) - 6.125 * Z(1) + 5.907

# Define the quantum kernel
@qjit
def ansatz(q : qreg, theta : float):
    X(q[0])
    Ry(q[1], theta)
    CX(q[1], q[0])

# Create the problem model, provide the state 
# prep circuit, Hamiltonian and note how many qubits
# and variational parameters 
num_params = 1
problemModel = qsim.ModelBuilder.createModel(ansatz, H, num_params)
```

The above example is for Python. C++ API is completely identical and is shown in the [VQE](#vqe-workflow) section below.

When the Hamiltonian operator is different from the observable operator, e.g. for systems with time-dependent Hamiltonian, users can provide this Hamiltonian as a function from time value to concrete operator value. Noted that a static Hamiltonian can be returned if the system is time-independent. Please refer to the [time-dependent simulation](#td-ham-workflow) section for examples.

## <a id="workflow"></a> Workflow 

The QSim library has built-in implementations for Variational Quantum Eigensolver algorithm (VQE), Quantum Approximate Optimization Algorithm (QAOA), Quantum Imaginary Time Evolution (QITE), and general time-dependent evolution workflows. Here, we show simple examples for common use cases and explain extra configuration parameters that each workflow may take.

### <a id="vqe-workflow"></a> Variational Quantum Eigensolver - VQE 

A Variational Quantum Eigensolver algorithm workflow instance can be retrieved from the QSim registry by calling `getWorkflow("vqe")` as shown in the below example.

<table>
<tr>
<th>Deuteron VQE - C++</th>
<th>Deuteron VQE - Python</th>
</tr>
<tr>
<td>

```cpp
#include "qcor_qsim.hpp"

// Define a fixed ansatz as a QCOR kernel
__qpu__ void ansatz(qreg q, double theta) {
  X(q[0]);
  auto exponent_op = X(0) * Y(1) - Y(0) * X(1);
  exp_i_theta(q, theta, exponent_op);
}

int main(int argc, char **argv) {
  // Create the Deuteron Hamiltonian
  auto H = 5.907 - 2.1433 * X(0) * X(1) - 2.143 * Y(0) * Y(1) + 0.21829 * Z(0) -
           6.125 * Z(1);
  const auto num_qubits = 2;
  const auto num_params = 1;
  auto problemModel =
      qsim::ModelBuilder::createModel(ansatz, H, num_qubits, num_params);
  auto optimizer = createOptimizer("nlopt");
  // Instantiate a VQE workflow with the nlopt optimizer
  auto workflow = qsim::getWorkflow("vqe", {{"optimizer", optimizer}});

  // Result should contain the ground-state energy along with the optimal
  // parameters.
  auto result = workflow->execute(problemModel);

  const auto energy = result.get<double>("energy");
  std::cout << "Ground-state energy = " << energy << "\n";
  return 0;
}
```
</td>
<td>

```python
from qcor import * 

# Define the deuteron hamiltonian 
H = -2.1433 * X(0) * X(1) - 2.1433 * \
    Y(0) * Y(1) + .21829 * Z(0) - 6.125 * Z(1) + 5.907

# Define the quantum kernel by providing a 
# python function that is annotated with qjit for 
# quantum just in time compilation
@qjit
def ansatz(q : qreg, theta : float):
    X(q[0])
    Ry(q[1], theta)
    CX(q[1], q[0])

# Create the problem model, provide the state 
# prep circuit, Hamiltonian and note how many qubits
# and variational parameters 
num_params = 1
problemModel = qsim.ModelBuilder.createModel(ansatz, H, num_params)
      
# Create the NLOpt derivative free optimizer
optimizer = createOptimizer('nlopt')

# Create the VQE workflow
workflow = qsim.getWorkflow('vqe', {'optimizer': optimizer})

# Execute and print the result
result = workflow.execute(problemModel)
energy = result['energy']
print(energy)
```
</td>
</tr>
</table>

As we may see, users can provide a specific optimizer instance to the VQE workflow to be used. By default, the `nlopt`(gradient-free) optimizer will be used if none is provided. 

VQE workflow returns the following information:

|   Result Key       |                  Description                                     | 
|--------------------|------------------------------------------------------------------|
| `energy`           | The final (optimized) energy (observable expectation value).     | 
| `opt-params`       | The list of optimized variational parameters.                    |

### <a id="qaoa-workflow"></a> Quantum Approximate Optimization Algorithm - QAOA 

The Quantum Approximate Optimization Algorithm (QAOA) workflow has the following configuration parameters:

|   Param Key        |                  Description                                           | Default |
|--------------------|------------------------------------------------------------------------|---------|
| `optimizer`        | The classical optimizer.| `nlopt`             |
| `steps`            | The integer parameter p as specified [here](https://arxiv.org/abs/1411.4028). | 1    |
| `parameter-scheme` | `Standard` or `Extended` parameterization scheme. In the `Extended` scheme, all rotation angles are considered as independent variational parameters.  |  `Standard`       |
| `gradient-strategy`| The gradient strategy to be used if the optimizer is gradient-based.     | `autodiff`  |

A simple QAOA workflow execution is shown in the below example.

<table>
<tr>
<th>Deuteron QAOA - C++</th>
<th>Deuteron QAOA - Python</th>
</tr>
<tr>
<td>

```cpp
#include "qcor_qsim.hpp"

int main(int argc, char **argv) {
  // Create the Deuteron Hamiltonian
  auto H = 5.907 - 2.1433 * X(0) * X(1) - 2.143 * Y(0) * Y(1) + 0.21829 * Z(0) -
           6.125 * Z(1);
  auto problemModel = qsim::ModelBuilder::createModel(H);
  auto optimizer = createOptimizer("nlopt");
  // Instantiate a QAOA workflow with the nlopt optimizer
  // "steps" = the (p) param in QAOA algorithm.
  auto workflow = qsim::getWorkflow("qaoa", {{"optimizer", optimizer}, {"steps", 8}});

  // Result should contain the ground-state energy along with the optimal
  // parameters.
  auto result = workflow->execute(problemModel);

  const auto energy = result.get<double>("energy");
  std::cout << "Ground-state energy = " << energy << "\n";
  return 0;
}
```
</td>
<td>

```python
from qcor import * 

# Solving deuteron problem using qsim QAOA

# Define the deuteron hamiltonian 
H = -2.1433 * X(0) * X(1) - 2.1433 * \
    Y(0) * Y(1) + .21829 * Z(0) - 6.125 * Z(1) + 5.907

problemModel = qsim.ModelBuilder.createModel(H)
      
# Create the NLOpt derivative free optimizer
optimizer = createOptimizer('nlopt')

# Create the QAOA workflow with p = 8 steps
workflow = qsim.getWorkflow('qaoa', {'optimizer': optimizer, 'steps': 8})

# Execute and print the result
result = workflow.execute(problemModel)
energy = result['energy']
print(energy)
```
</td>
</tr>
</table>

QAOA workflow returns the following information:

|   Result Key       |                  Description                                     | 
|--------------------|------------------------------------------------------------------|
| `energy`           | The final (optimized) energy (observable expectation value).     | 
| `opt-params`       | The list of optimized QAOA parameters (depending on the parameterization scheme).|

### <a id="qite-workflow"></a> Quantum Imaginary Time Evolution - QITE 

The Quantum Imaginary Time Evolution (QITE) workflow **requires** the following configuration parameters:

|   Param Key        |                  Description                                     | 
|--------------------|------------------------------------------------------------------|
| `step-size`        | The imaginary time step.                                         | 
| `steps`            | The number of time steps to evolve the system in imaginary time. |

Below is a simple example of using the QITE workflow.

<table>
<tr>
<th>QITE - C++</th>
<th>QITE - Python</th>
</tr>
<tr>
<td>

```cpp
#include "qcor_qsim.hpp"
int main(int argc, char **argv) {
  auto ham = 0.7071067811865475 * X(0) + 0.7071067811865475 * Z(0);
  // Number of QITE time steps and step size
  const int nbSteps = 25;
  const double stepSize = 0.1;
  auto problemModel = qsim::ModelBuilder::createModel(ham);
  auto workflow =
      qsim::getWorkflow("qite", {{"steps", nbSteps}, {"step-size", stepSize}});
  auto result = workflow->execute(problemModel);
  const auto energy = result.get<double>("energy");
  // Array of energy values at each QITE step
  const auto energyAtStep = result.get<std::vector<double>>("exp-vals");
  std::cout << "Ground state energy: " << energy << "\n";
  return 0;
}
```
</td>
<td>

```python
from qcor import * 

# Target H = 1/sqrt(2)(X + Z)
H = 0.7071067811865475 * X(0) + 0.7071067811865475 * Z(0)

# The number of Trotter steps 
nbSteps = 25

# The Trotter step size
stepSize = 0.1

# Create the problem model
problemModel = qsim.ModelBuilder.createModel(H)

# Create the QITE workflow
workflow = qsim.getWorkflow('qite', {'steps': nbSteps, 'step-size': stepSize})

# Execute and print the result
result = workflow.execute(problemModel)

# Final energy:
energy = result['energy']
print('Ground state energy =', energy)

# Energy values along QITE steps
td_energy_vals = result['exp-vals']
print(td_energy_vals)
```
</td>
</tr>
</table>

QITE workflow returns the following information:

|   Result Key       |                  Description                                     | 
|--------------------|------------------------------------------------------------------|
| `energy`           | The final energy at the end of the QITE time-stepping.           | 
| `exp-vals`         | QITE time-stepping expectation value data.                       |
| `circuit`          | The complete QITE circuit.                                       |

### <a id="td-ham-workflow"></a> Time-dependent Simulation 

The time-dependent simulation (`td-evolution`) workflow **requires** the following configuration parameters:

|   Param Key        |                  Description                                     | 
|--------------------|------------------------------------------------------------------|
| `dt`               | The Trotter time step.                                           | 
| `steps`            | The number of time steps to evolve the system.                   |

To execute a time-dependent simulation workflow, the problem model should provide a Hamiltonian function
taking time value as the input and returning the Hamiltonian operator.

This is illustrated in the below example.

<table>
<tr>
<th>Time-dependent - C++</th>
<th>Time-dependent - Python</th>
</tr>
<tr>
<td>

```cpp
#include "qcor_qsim.hpp"

int main(int argc, char **argv) {
  // Time-dependent Hamiltonian
  qsim::TdObservable H = [](double t) {
    // Parameters:
    const double Jz = 2 * M_PI * 2.86265 * 1e-3;
    const double epsilon = Jz; 
    const double omega = 4.8 * 2 * M_PI * 1e-3;
    return -Jz * Z(0) * Z(1) - Jz * Z(1) * Z(2) -
           epsilon * std::cos(omega * t) * (X(0) + X(1) + X(2));
  };

  // Observable = average magnetization
  auto observable = (1.0 / 3.0) * (Z(0) + Z(1) + Z(2));

  // Example: build model and TD workflow 
  auto problemModel = qsim::ModelBuilder::createModel(observable, H);
  // Trotter step = 3fs, number of steps = 100 -> end time = 300fs
  auto workflow = qsim::getWorkflow(
      "td-evolution", {{"dt", 3.0}, {"steps", 100}});

  // Result should contain the observable expectation value along Trotter steps.
  auto result = workflow->execute(problemModel);
  // Get the observable values (average magnetization)
  const auto obsVals = result.get<std::vector<double>>("exp-vals");

  return 0;
}

```
</td>
<td>

```python
from qcor import *
import numpy as np

# Time-dependent Hamiltonian: 
# Returns the Pauli operators at a time point.
def td_hamiltonian(t):
  Jz = 2 * np.pi * 2.86265 * 1e-3
  epsilon = Jz
  omega = 4.8 * 2 * np.pi * 1e-3
  return -Jz * Z(0) * Z(1)  - Jz * Z(1) * Z(2) + (-epsilon * np.cos(omega * t)) * (X(0) + X(1) + X(2)) 

# Observable = average magnetization
observable = (1.0 / 3.0) * (Z(0) + Z(1) + Z(2))

# Build model and TD workflow 
problemModel = qsim.ModelBuilder.createModel(observable, td_hamiltonian)
# TD workflow with hyper-parameters: 
# Trotter step = 3fs, number of steps = 100 -> end time = 300fs
workflow = qsim.getWorkflow(
      "td-evolution", {"dt": 3.0, "steps": 100})

# Result contains the observable expectation value along Trotter steps.
result = workflow.execute(problemModel)
obsVals = result["exp-vals"]
print(obsVals)
```
</td>
</tr>
</table>

Time-dependent simulation workflow returns the following information:

|   Result Key       |                  Description                                     | 
|--------------------|------------------------------------------------------------------|
| `exp-vals`         | The time-stepping expectation value data.                        |

## <a id="cost-eval"></a> Cost Function (Observable) Evaluate 

A common utility that is required across QSim workflows is the ability to *observe* the expectation value of an arbitrary operator at a specific quantum state (e.g., after the ansatz circuit or after a certain number of Trotter steps). 

This capability is provided by the `CostFunctionEvaluator` interface in the QSim library.

There are two `CostFunctionEvaluator` implementations currently available: the `default` one, which is based on the partial tomography method, and the quantum phase estimation (`qpe`)-based method, which can be optionally error-mitigated via the protocol described in this [paper](https://arxiv.org/pdf/2010.02538.pdf).

All workflows accept an optional `evaluator` key in addition to their set of configuration parameters to specify the `CostFunctionEvaluator` (via a name string or an instantiated instance). If none provided, the partial-tomography (`default`) one will be used.

The `CostFunctionEvaluator` configuration parameters, if any, can be provided in the workflow parameter pack, which will be forwarded to the `CostFunctionEvaluator` appropriately.

The `CostFunctionEvaluator` will use the runtime QPU instance to execute the necessary sub-circuits to evaluate the operator expectation value. 

### <a id="partial-tomo"></a> Partial Tomography 

The `default` CostFunctionEvaluator is based on the partial tomography method, whereby change-of-basis gates are added to measure the expectation values of each product term in the operator.

Users don't need to provide the `evaluator` key (and set it to `default`) when creating the workflow if they wish to use this method because all workflows assume this option.

It's worth noting that error mitigation (if any) for this cost evaluator is performed at the QPU level via conventional QCOR error mitigation decorators. 

### <a id="phase-est"></a> Quantum Phase Estimation

The `qpe` cost evaluator is based on the time-series quantum phase estimation method to estimate the expectation value. In particular, it makes use of the [Prony](https://en.wikipedia.org/wiki/Prony%27s_method) signal processing method to extract the expectation value estimate from the time-series QPE signal.

The `qpe` cost evaluator has the following configuration parameters:

|   Param Key        |                  Description                                     | 
|--------------------|------------------------------------------------------------------|
| `steps`            | The number of data points for classical signal processing. Default is 5, which is the minimum number of samples to estimate the energy of two-eigenvalue operators.|
| `verified`            | (True/False) If true, it will run the verified phase estimation protocol as described in this [paper](https://arxiv.org/pdf/2010.02538.pdf).|

The `qpe` cost evaluator can be explicitly instantiated by using the `getObjEvaluator` helper function and providing the
operator to be evaluated, the name key (`qpe`), and any additional parameters.

For example,

- In C++:

```cpp
auto observable = Z(0) + Z(1) + Z(2);
auto vqpeEvaluator = qsim::getObjEvaluator(observable, "qpe", {{"verified", true}});
```

- In Python:

```python
observable = Z(0) + Z(1) + Z(2)
vqpeEvaluator = qsim.getObjEvaluator(observable, 'qpe', {'verified': True})
```

## <a id="new-workflow"></a> Implement a new workflow

The workflow is described via an abstract `QuantumSimulationWorkflow` class:

```cpp
// Quantum Simulation Workflow (Protocol)
// This can handle both variational workflow (optimization loop)
// as well as simple Trotter evolution workflow.

// Workflow result is stored in a HetMap
using QuantumSimulationResult = HeterogeneousMap;

// Abstract workflow:
class QuantumSimulationWorkflow : public Identifiable {
public:
  virtual bool initialize(const HeterogeneousMap &params) = 0;
  virtual QuantumSimulationResult
  execute(const QuantumSimulationModel &model) = 0;
};
```

Similar to [creating a new `Optimizer`](/deploy/developers/implement_optimizer/), to create a new QSim workflow, one need to subclass `QuantumSimulationWorkflow` and provide a concrete implementation.

Specifically, we need to provide a `name` and `description` string (`Identifiable` interface) and implement the `initialize` and `execute` methods of the `QuantumSimulationWorkflow` interface. Generally-speaking, `initialize` is where we parse any user-provided configuration parameters that the workflow supports, and `execute` is where we run the workflow procedure. This may include constructing quantum circuits, evaluating those circuits to estimate operator expectation values, classical processing and/or optimization, etc.

For example, looking at the `vqe` workflow implementation, one may find this subclass declaration:

```cpp
// VQE-type workflow which involves an optimization loop, i.e. an Optimizer.
class VqeWorkflow : public QuantumSimulationWorkflow {
public:
  virtual bool initialize(const HeterogeneousMap &params) override;
  virtual QuantumSimulationResult
  execute(const QuantumSimulationModel &model) override;

  virtual const std::string name() const override { return "vqe"; }
  virtual const std::string description() const override { return ""; }

private:
  std::shared_ptr<Optimizer> optimizer;
  HeterogeneousMap config_params;
};
```

In the above code, we create a new workflow named `vqe` and add any internal member variables as needed.

The simplified implementation of the `initialize` and `execute` methods are shown below.

```cpp
bool VqeWorkflow::initialize(const HeterogeneousMap &params) {
  const std::string DEFAULT_OPTIMIZER = "nlopt";
  optimizer.reset();
  if (params.pointerLikeExists<Optimizer>("optimizer")) {
    optimizer =
        xacc::as_shared_ptr(params.getPointerLike<Optimizer>("optimizer"));
  } else {
    optimizer = createOptimizer(DEFAULT_OPTIMIZER);
  }
  config_params = params;
  // VQE workflow requires an optimizer
  return (optimizer != nullptr);
}

QuantumSimulationResult
VqeWorkflow::execute(const QuantumSimulationModel &model) {
  auto nParams = model.user_defined_ansatz->nParams();
  evaluator = getEvaluator(model.observable, config_params);

  OptFunction f(
      [&](const std::vector<double> &x, std::vector<double> &dx) {
        auto kernel = model.user_defined_ansatz->evaluate_kernel(x);
        auto energy = evaluator->evaluate(kernel);
        return energy;
      },
      nParams);

  auto result = optimizer->optimize(f);
  return {{"energy", result.first}, {"opt-params", result.second}};
}
```

As previously described, the VQE algorithm requires a classical optimizer hence we need to figure out which optimizer should be used during initialization.  In this case, we look for the `optimizer` key if provided. Otherwise, we just fall back to a default one (`nlopt` in this case).

Similarly, one may preset (providing default values) and parse any number of configuration parameters that his custom workflow support.

During workflow's `execute`, one can take advantage of QCOR API's to construct the quantum circuit. In this simple VQE workflow, the ansatz circuit was provided as a QCOR kernel functor (`user_defined_ansatz`), hence, we just need to evaluate (resolving variational gate parameters) during the optimization loop.

One key element of implementing workflow execution is to hook up the appropriate cost function evaluator. In that regard, QSim provides a utility function `getEvaluator` which will pick the appropriate evaluator based on user configurations, e.g., selecting the `default` (tomography-based) evaluator if none provided. 

Workflow developers are free to *not* use the `getEvaluator` utility if the workflow doesn't need to evaluate (observe) the operator or requires custom logic in selecting the evaluator.

Workflow developers are free to select which information to be returned at the end of the workflow execution. In particular, the workflow returns a heterogeneous key-value map (dictionary). In the VQE example, we returned the optimized energy value as well as the optimal parameters.

Lastly, one needs to register the new workflow implementation with the QSim library so that users can retrieve the new workflow via the QSim workflow registry (via QSim `getWorkflow` function).

This can be achieved by adding a `RegisterService` entry to the `QuantumSimulationActivator::Start` method, e.g.

```cpp
void Start(BundleContext context) {
 // .... Other workflows
 context.RegisterService<qsim::QuantumSimulationWorkflow>(
        std::make_shared<qsim::VqeWorkflow>());
}
```

Congratulations! You have completed a new QSim workflow that will be available to all QSim users (C++ and Python). 