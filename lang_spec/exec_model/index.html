<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Execution Model - AIDE-QC</title><meta name=description content="Advanced Integrated Development Environment for Quantum Computing"><meta name=generator content="Hugo 0.76.5"><link href=https://aide-qc.github.io/deployindex.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://aide-qc.github.io/deploy/lang_spec/exec_model/><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://aide-qc.github.io/deploy/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://aide-qc.github.io/deploy/aide_qc_logo_v3.png width=40px align=absmiddle>
AIDE-QC</div></h1><p class=description>Advanced Integrated Development Environment for Quantum Computing</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://aideqc.slack.com>AIDE-QC Slack</a></li><li class=child><a href=https://xacc-dev.slack.com>XACC/QCOR Slack</a></li></ul></li><li class=parent><a href=https://github.com/aide-qc>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://ornl-qci.github.io/qcor-api-docs/>QCOR Doxygen</a></li><li class=child><a href=https://ornl-qci.github.io/xacc-api-docs/>XACC Doxygen</a></li><li class=child><a href=https://github.com/aide-qc/qcor>QCOR</a></li><li class=child><a href=https://github.com/aide-qc/xacc>XACC</a></li></ul></li><li><a href=https://github.com/aide-qc/aide-qc/issues>Bugs</a></li><li><a href=http://aide-qc.org>Project Page</a></li></ul></nav></div><div class=content-container><main><h1>Execution Model</h1><p>The QCOR execution model considers a hybrid quantum-classical compute system that enables execution of quantum kernels on available quantum coprocessors in a quantum-hardware agnostic fashion. The host-side, classical execution model should simply be the execution model of the language being extended (e.g. C++, Python, etc.).</p><p>QCOR treats the quantum coprocessors as an abstract machine that loads and executes general host-specified quantum instructions and persists measurement results (measured classical bits) to a quantum-processor-local discrete memory space, with synchronization of that memory space with the host-side handled implicitly by language extension implementations. Each specified quantum instruction for execution carries with it information about its unique instruction identifier, the qubit to operate upon (the index of the qubit in the infinitely-sized, assumed global qubit register, see
<a href=/deploy/lang_spec/memory/>Memory Model</a>
), and any required or extra metadata about the operation. Quantum instructions loaded for execution can be single instructions or a composite of single instructions, thereby enabling one to submit, load, and execute entire quantum circuits or programs.</p><p>This latter point enables the QCOR execution model to retain a multi-modal characteristic. The execution model should enable both near-term, loosely-coupled (remotely-hosted) batch circuit execution models (NISQ mode execution), as well as future, tightly integrated CPU-QPU architectures with fast-feedback (FTQC mode execution, fault-tolerant quantum computing). FTQC mode execution streams quantum instruction executions, i.e. as the program is running, invoked quantum instructions will affect the qubit register as soon as they are encountered. NISQ mode execution should instead queue encountered quantum instructions and flush the queue upon exiting an entry-point quantum kernel.</p><p>Language implementations should enable both modes of execution, and this implies additional programming capabilities that may exist in one mode over the other. For example, FTQC mode execution should enable programmers to leverage the classical language control flow structures enabling fast-feedback on qubit measurement results.</p><p>Here are two examples showing the differences in programming for NISQ and FTQC mode execution (in a C++ QCOR language extension). First we show FTQC mode execution, where one can clearly see the ability to stream quantum instruction invocations, followed by conditional statements on qubit measurement results.</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>__qpu__</span> <span class=kt>void</span> <span class=nf>PrepareStateUsingRUS</span><span class=p>(</span><span class=n>qreg</span> <span class=n>q</span><span class=p>,</span> <span class=kt>int</span> <span class=n>maxIter</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Note: target = q[0], aux = q[1]
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>q</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>head</span><span class=p>();</span>
  <span class=k>auto</span> <span class=n>r</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>tail</span><span class=p>();</span>
  <span class=n>H</span><span class=p>(</span><span class=n>r</span><span class=p>);</span>
  <span class=c1>// We limit the max number of RUS iterations.
</span><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>maxIter</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>Tdg</span><span class=p>(</span><span class=n>r</span><span class=p>);</span>
    <span class=n>X</span><span class=o>::</span><span class=n>ctrl</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=n>r</span><span class=p>);</span>
    <span class=n>T</span><span class=p>(</span><span class=n>r</span><span class=p>);</span>

    <span class=c1>// In order to measure in the PauliX basis, changes the basis.
</span><span class=c1></span>    <span class=n>H</span><span class=p>(</span><span class=n>r</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>Measure</span><span class=p>(</span><span class=n>r</span><span class=p>))</span> <span class=p>{</span>
      <span class=c1>// Success (until (outcome == Zero))
</span><span class=c1></span>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Success after &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; iterations.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
      <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span> 
    <span class=k>else</span> <span class=p>{</span>
      <span class=c1>// Measure 1: |1&gt; state
</span><span class=c1></span>      <span class=c1>// Fix up: Bring the auxiliary and target qubits back to |+&gt; state.
</span><span class=c1></span>      <span class=n>X</span><span class=p>(</span><span class=n>r</span><span class=p>);</span>
      <span class=n>H</span><span class=p>(</span><span class=n>r</span><span class=p>);</span>
      <span class=n>X</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
      <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Next, we show the construction of a QAOA ansatz on a general cost Hamiltonian. We still get the usual control flow (<code>for</code> loops, etc.), but the circuit is in a sense constructed by this quantum kernel before ultimate execution on the loosely-coupled quantum processor. The stream of instructions is implicitly flushed (executed) upon exiting this entry-point quantum kernel.</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>__qpu__</span> <span class=kt>void</span> <span class=nf>qaoa_ansatz</span><span class=p>(</span><span class=n>qreg</span> <span class=n>q</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n_steps</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>gamma</span><span class=p>,</span>
                         <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>beta</span><span class=p>,</span> <span class=n>Operator</span> <span class=n>cost_ham</span><span class=p>)</span> <span class=p>{</span>

  <span class=c1>// Local Declarations
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>nQubits</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
  <span class=kt>int</span> <span class=n>gamma_counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=kt>int</span> <span class=n>beta_counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

  <span class=c1>// Start of in the uniform superposition
</span><span class=c1></span>  <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>

  <span class=c1>// Get all non-identity hamiltonian terms
</span><span class=c1></span>  <span class=c1>// for the following exp(H_i) trotterization
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>cost_terms</span> <span class=o>=</span> <span class=n>cost_ham</span><span class=p>.</span><span class=n>getNonIdentitySubTerms</span><span class=p>();</span>

  <span class=c1>// Loop over qaoa steps
</span><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>step</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>step</span> <span class=o>&lt;</span> <span class=n>n_steps</span><span class=p>;</span> <span class=n>step</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>

    <span class=c1>// Loop over cost hamiltonian terms
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>cost_terms</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>

      <span class=k>auto</span> <span class=n>cost_term</span> <span class=o>=</span> <span class=n>cost_terms</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
      <span class=k>auto</span> <span class=n>m_gamma</span> <span class=o>=</span> <span class=n>gamma</span><span class=p>[</span><span class=n>gamma_counter</span><span class=p>];</span>

      <span class=c1>// trotterize
</span><span class=c1></span>      <span class=n>exp_i_theta</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=n>m_gamma</span><span class=p>,</span> <span class=n>cost_term</span><span class=p>);</span>

      <span class=n>gamma_counter</span><span class=o>++</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Add the reference hamiltonian term
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nQubits</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>auto</span> <span class=n>ref_ham_term</span> <span class=o>=</span> <span class=n>X</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
      <span class=k>auto</span> <span class=n>m_beta</span> <span class=o>=</span> <span class=n>beta</span><span class=p>[</span><span class=n>beta_counter</span><span class=p>];</span>
      <span class=n>exp_i_theta</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=n>m_beta</span><span class=p>,</span> <span class=n>ref_ham_term</span><span class=p>);</span>
      <span class=n>beta_counter</span><span class=o>++</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><div class=edit-meta><br><a href=https://github.com/aide-qc/deploy//edit/master/website/content/lang_spec/exec_model.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/deploy/lang_spec/data_model/ title="Data Model"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Data Model</a>
<a class="nav nav-next" href=/deploy/lang_spec/memory/ title="Memory Model">Next - Memory Model <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://aide-qc.github.io/deploy>Home</a></li><li class=has-sub-menu><a href=/deploy/background/>Background<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/background/qcor/>QCOR C++ Compiler and JIT Engine</a></li><li><a href=/deploy/background/xacc/>XACC Quantum Programming Framework</a></li><li><a href=/deploy/background/project/></a></li></ul></li><li class=has-sub-menu><a href=/deploy/developers/>Developer Guide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/developers/implement_circuit_synthesis/>Add a New Circuit Synthesis Strategy</a></li><li><a href=/deploy/developers/implement_optimizer/>Add a New Optimizer</a></li><li><a href=/deploy/developers/implement_accelerator/>Add a New Quantum Backend</a></li><li><a href=/deploy/developers/implement_quasimo_workflow/>Add a New QuaSiMo Workflow</a></li><li><a href=/deploy/developers/implement_plugin_embedded_python/>Hybrid C++ / Python Plugins</a></li><li><a href=/deploy/developers/clang_syntax/></a></li></ul></li><li class=has-sub-menu><a href=/deploy/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/getting_started/Faq/>Frequently Asked Questions</a></li><li><a href=/deploy/getting_started/build_from_source/>Build Everything from Source</a></li></ul></li><li class="parent has-sub-menu"><a href=/deploy/lang_spec/>QCOR Classical Language Extension<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/deploy/lang_spec/data_model/>Data Model</a></li><li class=active><a href=/deploy/lang_spec/exec_model/>Execution Model</a></li><li><a href=/deploy/lang_spec/memory/>Memory Model</a></li><li><a href=/deploy/lang_spec/prog_model/>Programming Model</a></li></ul></li><li class=has-sub-menu><a href=/deploy/users/>User Guide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/users/hello_world/>Hello World</a></li><li><a href=/deploy/users/operators/>Operators</a></li><li><a href=/deploy/users/pass_manager/>Pass Manager</a></li><li><a href=/deploy/users/qjit/>Quantum JIT (QJIT)</a></li><li><a href=/deploy/users/quantum_kernels/>Quantum Kernels</a></li><li><a href=/deploy/users/quasimo/>Quantum Simulation Modeling (QuaSiMo)</a></li><li><a href=/deploy/users/remote_qpu_creds/>Remote QPU Credentials</a></li><li><a href=/deploy/users/tnqvm/>Tensor Network Quantum Virtual Machine</a></li><li><a href=/deploy/users/using_optimizer/>Using an Optimizer</a></li><li><a href=/deploy/users/variational/>Variational Algorithms</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>