<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>QCOR Classical Language Extension on AIDE-QC</title><link>https://aide-qc.github.io/deploy/lang_spec/</link><description>Recent content in QCOR Classical Language Extension on AIDE-QC</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://aide-qc.github.io/deploy/lang_spec/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Model</title><link>https://aide-qc.github.io/deploy/lang_spec/data_model/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/lang_spec/data_model/</guid><description>Variational Data Model Due to the ubiquity of variational quantum algorithms in near-term quantum computation, the QCOR language specification puts forward novel data-types that enable efficient programming of quantum-classical variational algorithms. We specify the structure of these types here:
HeterogeneousMap HeterogeneousMap is used across the QCOR variational API as a container for a heterogeneous mapping of data. Specifically, this data type should map string keys to values of any type. This can be accomplished in C++ for instance via a std::map&amp;lt;std::string, std::any&amp;gt;.</description></item><item><title>Execution Model</title><link>https://aide-qc.github.io/deploy/lang_spec/exec_model/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/lang_spec/exec_model/</guid><description>The QCOR execution model considers a hybrid quantum-classical compute system that enables execution of quantum kernels on available quantum coprocessors in a quantum-hardware agnostic fashion. The host-side, classical execution model should simply be the execution model of the language being extended (e.g. C++, Python, etc.).
QCOR treats the quantum coprocessors as an abstract machine that loads and executes general host-specified quantum instructions and persists measurement results (measured classical bits) to a quantum-processor-local discrete memory space, with synchronization of that memory space with the host-side handled implicitly by language extension implementations.</description></item><item><title>Memory Model</title><link>https://aide-qc.github.io/deploy/lang_spec/memory/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/lang_spec/memory/</guid><description>The qcor memory model assumes two classical memory spaces: (1) the host memory space, and (2) the memory space leveraged by the classical control electronics driving the execution of quantum operations. The model assumes an infinite-sized global register of quantum bits (qubits), and that programmers can allocate sub-registers of this global register via allocation library calls. The qcor memory model therefore consists of both classical and quantum components. The classical host memory space should adhere to the memory model of the language being extended (C++, Python, etc.</description></item><item><title>Programming Model</title><link>https://aide-qc.github.io/deploy/lang_spec/prog_model/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/lang_spec/prog_model/</guid><description>qcor enables the programming of heterogeneous quantum-classical computing tasks, whereby programmers are free to leverage both classical and quantum processors to achieve some hybrid workflow goal. One can think of the types of hybrid quantum-classical programs that qcor enables as sitting on a spectrum with purely classical codes on one end and purely quantum codes on the other (with required classical driver code). Our programming model enables one to program across this spectrum, thereby enabling a language expression mechanism for near-term, noisy intermediate-scale as well as future fault-tolerant quantum tasks.</description></item></channel></rss>