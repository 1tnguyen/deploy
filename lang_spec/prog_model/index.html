<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Programming Model - AIDE-QC</title><meta name=description content="Advanced Integrated Development Environment for Quantum Computing"><meta name=generator content="Hugo 0.76.5"><link href=https://aide-qc.github.io/deployindex.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://aide-qc.github.io/deploy/lang_spec/prog_model/><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://aide-qc.github.io/deploy/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://aide-qc.github.io/deploy/aide_qc_logo_v3.png width=40px align=absmiddle>
AIDE-QC</div></h1><p class=description>Advanced Integrated Development Environment for Quantum Computing</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://aideqc.slack.com>AIDE-QC Slack</a></li><li class=child><a href=https://xacc-dev.slack.com>XACC/QCOR Slack</a></li></ul></li><li class=parent><a href=https://github.com/aide-qc>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://ornl-qci.github.io/qcor-api-docs/>QCOR Doxygen</a></li><li class=child><a href=https://ornl-qci.github.io/xacc-api-docs/>XACC Doxygen</a></li><li class=child><a href=https://github.com/aide-qc/qcor>QCOR</a></li><li class=child><a href=https://github.com/aide-qc/xacc>XACC</a></li></ul></li><li><a href=https://github.com/aide-qc/aide-qc/issues>Bugs</a></li><li><a href=http://aide-qc.org>Project Page</a></li></ul></nav></div><div class=content-container><main><h1>Programming Model</h1><p>qcor enables the programming of heterogeneous quantum-classical computing tasks, whereby programmers are free to leverage both classical and quantum processors to achieve some hybrid workflow goal. One can think of the types of hybrid quantum-classical programs that qcor enables as sitting on a spectrum with purely classical codes on one end and purely quantum codes on the other (with required classical driver code). Our programming model enables one to program across this spectrum, thereby enabling a language expression mechanism for near-term, noisy intermediate-scale as well as future fault-tolerant quantum tasks.</p><p>qcor requires that specification implementors extend classical programming languages with support for quantum coprocessors in a single-source manner. This requirement directly promotes familiarity and usability for domain computational scientist, and lowers the learning curve for separate quantum and classical compiler workflows and manual integration to produce quantum-classical executables. This single-source language extension approach enables quantum-classical tasks to be constructed using high level classical language syntax via intrinsic library calls and compiler preprocessor directives.</p><h3 id=allocating-quantum-memory>Allocating Quantum Memory&nbsp;<a class=headline-hash href=#allocating-quantum-memory>¶</a></h3><p>As described in the
<a href=/deploy/lang_spec/memory/>Memory Model</a>
, qcor specifies <code>qubit</code> and <code>qreg</code> types that serve as a handle on allocated quantum memory. Allocation of quantum memory is achieved through an intrinsic library call named <code>qalloc</code> (must be provided by language extension implementation runtime library), which returns an allocated <code>qreg</code> instance of the programmer-specified size. Deallocation of quantum resources should occur implicitly when the <code>qreg</code> instance goes out of scope. While the <code>qubit</code> type is specified to be opaque, the <code>qreg</code> type should provide a public API for sub-register extraction, individual <code>qubit</code> addressing, slicing, concatenation, and retrieval of <code>qubit</code> measurement results. qcor specifies two function overloads for <code>qalloc()</code>: (1) the default that takes an <code>int</code>-like data type describing the size of the register, and (2) an overload that takes the size and a <code>bool</code> indicating that stack-allocated <code>qubit</code> instances will be uncomputed manually (<code>true</code> indicates that uncomputation will be manual and handled by the programmer).</p><p>Basic <code>qreg</code> usage:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>auto</span> <span class=n>q</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
<span class=n>kernel</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
<span class=k>auto</span> <span class=n>counts</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>counts</span><span class=p>();</span>
<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=p>[</span><span class=n>bits</span><span class=p>,</span> <span class=n>count</span><span class=p>]</span> <span class=o>:</span> <span class=n>counts</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>print</span><span class=p>(</span><span class=n>bits</span><span class=p>,</span> <span class=s>&#34;:&#34;</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>Basic <code>qreg</code> operations within kernels:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>__qpu__</span> <span class=kt>void</span> <span class=nf>kernel</span><span class=p>(</span><span class=n>qreg</span> <span class=n>q</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>auto</span> <span class=n>first</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>head</span><span class=p>();</span>
    <span class=k>auto</span> <span class=n>first_n</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>head</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
    <span class=k>auto</span> <span class=n>last</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>tail</span><span class=p>();</span>
    <span class=k>auto</span> <span class=n>last_n</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>tail</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
    <span class=k>auto</span> <span class=n>extracted</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>extract</span><span class=p>({</span><span class=mi>3</span><span class=p>,</span> <span class=mi>14</span><span class=p>});</span>
    <span class=k>auto</span> <span class=n>addressed</span> <span class=o>=</span> <span class=n>q</span><span class=p>[</span><span class=mi>13</span><span class=p>];</span>

    <span class=k>auto</span> <span class=n>ancilla</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></div><h3 id=quantum-kernels>Quantum Kernels&nbsp;<a class=headline-hash href=#quantum-kernels>¶</a></h3><p>To adhere to the single-source requirement promoted by qcor, quantum code intended for compilation and execution targeting a desired quantum coprocessor should be expressed as typical callables in the source language being extended. Examples of this would be standard functions in C++, Python, Julia, etc., closures/lambdas in C++, or structs with <code>operator()()</code> defined in C++. Quantum kernels provided as standard functions or lambdas should be able to reference and call previously defined or declared classical functions, classical global variables, and quantum kernels. Quantum kernels provided as lambdas should be able to capture classical variables from parent scope. Quantum kernel lambdas should not be able to capture quantum data (<code>qreg</code>). All quantum data must be provided to the quantum kernel via function argument (except for in-kernel, stack-allocated <code>qreg</code> instances).</p><p>The quantum kernel function signature can have any structure, however, the return type must be <code>void</code>. The body of the callable should contain code expressing the quantum program to be executed on the quantum coprocessor. The function body language is the native language being extended (for classical control flow and classical data allocation), plus the invocation of
<a href=#q-intr>Quantum Intrinsic Operations</a>
,
<a href=#q-patterns>common quantum programming patterns</a>
, or
<a href=#q-unitary>unitary matrix decompositions</a>
. As a native language extension, the qcor programming model specifies that any classical control flow be available within quantum kernel definitions. Programmers should be able to fully use <code>for</code> and <code>while</code> loops (for example) as expected, as well as <code>if</code> statements (<code>if {} else {}</code>, etc.), even in the case of conditional sub-circuit execution based on qubit measurement feedback.</p><p>Quantum kernels, as functional callables, should also be able to be passed as parameters to other function-like objects (or other quantum kernels). A typical use case for this would be the development of a generic quantum algorithm that is parameterized on some oracle (which would be expressed as some other quantum kernel).</p><p>Defined quantum kernels should expose a public API that produces related quantum kernels, or kernel-specific metadata. By related quantum kernels, we mean new quantum kernels that are defined in relation to the original kernel. Methods that must be on the quantum kernel are (here we use static method definitions, but one could also use instance methods (<code>.</code>) as well):</p><ul><li><code>kernel::ctrl( qubit*, Args...)</code>, which takes an array-like of <code>qubits</code> (e.g. C++ implementation may use <code>std::vector&lt;qubit></code>) as the control qubits, takes all usual kernel arguments</li><li><code>kernel::adjoint(Args...)</code>, which takes the original kernel arguments but applies the reverse of the kernel, or adjoint</li><li><code>kernel::observe(Operator*, Args...)</code> to take an unmeasured kernel and return the expected value of the given
<a href=/deploy/lang_spec/data_model/><code>Operator</code></a>
at the provided kernel arguments.</li><li><code>kernel::print(Stream&, Args...)</code> to print a QASM-like representation of the defined kernel in the native gateset of the target backend.</li></ul><p>Quantum kernels can be invoked from other quantum kernels, enabling a hierarchical representation of complex programs as well as the integration of pre-developed quantum library code (e.g. libraries for quantum Fourier transformations, Hadamard and Swap tests, etc.). The specification denotes a quantum kernel that is called from host classical code as an <strong>entry-point quantum kernel</strong>, in order to differentiate itself from quantum kernels invoked from other quantum kernels. All entry-point quantum kernels must take at least one <code>qreg</code> or <code>qubit</code> instance in order to ensure that downstream classical code can retrieve quantum execution results.</p><h4 id=a-idq-intraquantum-intrinsic-operations-and-expressions><a id=q-intr></a>Quantum Intrinsic Operations and Expressions&nbsp;<a class=headline-hash href=#a-idq-intraquantum-intrinsic-operations-and-expressions>¶</a></h4><p>Quantum intrinsic operations are quantum instructions provided by the language extension implementation that can only be invoked from within quantum kernels (they are not runtime library calls, instead they are native expressions in the language being extended). These should typically be quantum gate calls that are native to the language extension and affect execution of the specific instruction on the targeted quantum coprocessor. The implementation is free to define a list of default available quantum instructions, but typically one should provide instruction calls for <code>Hadamard</code>, <code>X</code>, <code>Y</code>, <code>Z</code>, <code>Rx</code>, <code>Ry</code>, <code>Rz</code>, <code>controlled-X</code>, <code>controlled-Y</code>, <code>controlled-Z</code>, <code>controlled-Hadamard</code>, <code>phase</code>, <code>T</code>, <code>Swap</code>, and <code>Reset</code> operations.</p><p>All single-qubit operations should also provide the usual <code>kernel::ctrl(...)</code> operation (e.g. enable operations like <code>X::ctrl({q,r}, s) == Toffoli(q,r,s)</code>). All single qubit intrinsic operations should broadcast over provided <code>qreg</code> instances, i.e. given a <code>qreg</code> instead of a <code>qubit</code>, quantum operations should apply the operation to all qubits in the <code>qreg</code>. Two qubit operations should also broadcast according to the following rules: <code>OP(qreg_0, qreg_1) == OP(qreg_0[i], qreg_1[i]) for all i in qreg_0.size()</code> (<code>qreg</code> must have same size).</p><p>Here is a basic example in C++ demonstrating kernel definition using quantum intrinsic operations, <code>::ctrl</code>, <code>Measure</code> broadcast on all qubits in <code>q</code>, and classical control flow.</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>__qpu__</span> <span class=kt>void</span> <span class=nf>ghz</span><span class=p>(</span><span class=n>qreg</span> <span class=n>q</span><span class=p>)</span> <span class=p>{</span>                   <span class=c1>// NOTES:
</span><span class=c1></span>    <span class=k>auto</span> <span class=n>first_qubit</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>head</span><span class=p>();</span>             <span class=c1>// qreg API
</span><span class=c1></span>    <span class=n>H</span><span class=p>(</span><span class=n>first_qubit</span><span class=p>);</span>                          <span class=c1>// Quantum Intrinsic Operation
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>i</span> <span class=p>:</span> <span class=n>range</span><span class=p>(</span><span class=n>q</span><span class=p>.</span><span class=n>size</span><span class=p>()</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span> <span class=p>{</span>       <span class=c1>// Can use C++ ctrl flow
</span><span class=c1></span>        <span class=n>X</span><span class=o>::</span><span class=n>ctrl</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]);</span>               <span class=c1>// Single qubit gates have ::ctrl
</span><span class=c1></span>    <span class=p>}</span>
    <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>                              <span class=c1>// qreg operation broadcasting
</span><span class=c1></span><span class=p>}</span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>auto</span> <span class=n>q</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>                     <span class=c1>// Allocate 10 qubits, standard library qalloc
</span><span class=c1></span>    <span class=n>ghz</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>                                  <span class=c1>// Invoke the quantum kernel
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=p>[</span><span class=n>bits</span><span class=p>,</span> <span class=n>count</span><span class=p>]</span> <span class=o>:</span> <span class=n>q</span><span class=p>.</span><span class=n>counts</span><span class=p>())</span> <span class=p>{</span>  <span class=c1>// Read out the results
</span><span class=c1></span>        <span class=n>print</span><span class=p>(</span><span class=n>bits</span><span class=p>,</span> <span class=s>&#34;:&#34;</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=c1>// qreg q out of scope, deallocation occurs
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><h5 id=a-idq-patternsa-compute-action-uncompute><a id=q-patterns></a>Compute-Action-Uncompute&nbsp;<a class=headline-hash href=#a-idq-patternsa-compute-action-uncompute>¶</a></h5><p>The specification requires that implementations enable novel syntax within quantum kernels for the ubiquitous <strong>compute-action-uncompute</strong> pattern. Given unitary operations <code>U</code>, <code>V</code> on <code>N</code> qubits, the sequence <code>U V U^</code> (here, <code>U^</code> is the adjoint of <code>U</code>) represents a common pattern across a number of quantum algorithms, where we have <strong>compute</strong><code> == U</code>, <strong>action</strong><code> == V</code>, and <strong>uncompute</strong><code> == U^</code>. Implementations are required to enable the expression of this pattern via keywords in the language extension: <strong>compute</strong> <code>COMPUTE SCOPE</code> <strong>action</strong> <code>ACTION SCOPE</code>. The intent is to ease expression of redundant quantum code, but also to promote compiler optimizations in the case of <code>W::ctrl(...), W == U V U^</code> (here <code>W::ctrl(...) == U V::ctrl(...) U^</code> instead of the naive <code>U::ctrl(...) V::ctrl(...) U^::ctrl(...)</code>). In a C++ language extension adherent to this specification, this pattern might look like this:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=c1>// Quantum kernels can be lambdas as well as functions
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>foo</span> <span class=o>=</span> <span class=n>qpu_lambda</span><span class=p>([](</span><span class=n>qreg</span> <span class=n>q</span><span class=p>)</span> <span class=p>{</span>
     <span class=k>auto</span> <span class=n>N</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
     <span class=n>compute</span> <span class=p>{</span>
        <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
        <span class=n>X</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
     <span class=p>}</span> <span class=n>action</span> <span class=p>{</span>
        <span class=n>Z</span><span class=o>::</span><span class=n>ctrl</span><span class=p>(</span><span class=n>q</span><span class=p>.</span><span class=n>head</span><span class=p>(),</span> <span class=n>q</span><span class=p>.</span><span class=n>tail</span><span class=p>(</span><span class=n>N</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>
     <span class=p>}</span>
  <span class=p>};</span>
<span class=p>}</span>
</code></pre></div><p>Here, the compiler implementation would expand this to <code>H(q) X(q) Z::ctrl(...) X(q) H(q)</code>, and any quantum code that called <code>foo::ctrl(...)</code> would result only in a control on the existing <code>controlled-Z</code>.</p><h5 id=a-idq-unitaryaunitary-matrix-decomposition><a id=q-unitary></a>Unitary Matrix Decomposition&nbsp;<a class=headline-hash href=#a-idq-unitaryaunitary-matrix-decomposition>¶</a></h5><p>The specification requires that implementations enable the expression of circuit synthesis from defined unitary matrices, enabling one to program quantum code at the matrix-level and let the compiler decompose into native gates for the quantum coprocessor. This is enabled via a <strong>decompose</strong> <code>MATRIX SCOPE</code> <code>(ARGS...)</code> expression, where <code>MATRIX SCOPE</code> contains the code describing the unitary matrix to be decomposed. The explicit circuit synthesis strategy is left up to concrete language implementations. The <code>ARGS...</code> must start with the <code>qubit</code> or <code>qreg</code> that the operation is to be applied to, and can contain any other circuit synthesis pertinent arguments. In a C++ language extension adherent to this specification, this expression might look like this:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// Fermionic Simulation gate:
</span><span class=c1>// FSimGate(θ, φ) = 
</span><span class=c1>// [[1, 0, 0, 0],
</span><span class=c1>//  [0, a, b, 0],
</span><span class=c1>//  [0, b, a, 0],
</span><span class=c1>//  [0, 0, 0, c]]
</span><span class=c1>// where:
</span><span class=c1>// a = cos(theta)
</span><span class=c1>// b = -i·sin(theta)
</span><span class=c1>// c = exp(-i·phi)
</span><span class=c1></span><span class=n>__qpu__</span> <span class=kt>void</span> <span class=nf>FSimGate</span><span class=p>(</span><span class=n>qubit</span> <span class=n>q0</span><span class=p>,</span> <span class=n>qubit</span> <span class=n>q1</span><span class=p>,</span> <span class=kt>double</span> <span class=n>theta</span><span class=p>,</span> <span class=kt>double</span> <span class=n>phi</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>qubit</span><span class=o>&gt;</span> <span class=n>qubits</span><span class=p>{</span><span class=n>q0</span><span class=p>,</span> <span class=n>q1</span><span class=p>};</span>
  <span class=n>qreg</span> <span class=n>q</span><span class=p>(</span><span class=n>qubits</span><span class=p>);</span>
  <span class=k>auto</span> <span class=n>a</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>cos</span><span class=p>(</span><span class=n>theta</span><span class=p>);</span>
  <span class=k>auto</span> <span class=n>b</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>complex</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>{</span> <span class=mf>0.0</span><span class=p>,</span> <span class=o>-</span><span class=n>std</span><span class=o>::</span><span class=n>sin</span><span class=p>(</span><span class=n>theta</span><span class=p>)};</span>
  <span class=k>auto</span> <span class=n>c</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>exp</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>complex</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>{</span> <span class=mf>0.0</span><span class=p>,</span> <span class=o>-</span><span class=n>phi</span><span class=p>});</span>
  <span class=c1>// Decompose using KAK
</span><span class=c1></span>  <span class=n>decompose</span> <span class=p>{</span>
    <span class=c1>// Create the unitary matrix
</span><span class=c1></span>    <span class=n>UnitaryMatrix</span> <span class=n>fsim_mat</span> <span class=o>=</span> <span class=n>UnitaryMatrix</span><span class=o>::</span><span class=n>Identity</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
    <span class=n>fsim_mat</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
    <span class=n>fsim_mat</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
    <span class=n>fsim_mat</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
    <span class=n>fsim_mat</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
    <span class=n>fsim_mat</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=o>=</span> <span class=n>c</span><span class=p>;</span>
  <span class=p>}(</span><span class=n>q</span><span class=p>,</span> <span class=n>kak</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><div class=edit-meta><br><a href=https://github.com/aide-qc/deploy//edit/master/website/content/lang_spec/prog_model.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/deploy/lang_spec/memory/ title="Memory Model"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Memory Model</a>
<a class="nav nav-next" href=/deploy/users/ title="User Guide">Next - User Guide <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://aide-qc.github.io/deploy>Home</a></li><li class=has-sub-menu><a href=/deploy/background/>Background<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/background/qcor/>QCOR C++ Compiler and JIT Engine</a></li><li><a href=/deploy/background/xacc/>XACC Quantum Programming Framework</a></li><li><a href=/deploy/background/project/></a></li></ul></li><li class=has-sub-menu><a href=/deploy/developers/>Developer Guide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/developers/implement_circuit_synthesis/>Add a New Circuit Synthesis Strategy</a></li><li><a href=/deploy/developers/implement_optimizer/>Add a New Optimizer</a></li><li><a href=/deploy/developers/implement_accelerator/>Add a New Quantum Backend</a></li><li><a href=/deploy/developers/implement_quasimo_workflow/>Add a New QuaSiMo Workflow</a></li><li><a href=/deploy/developers/implement_plugin_embedded_python/>Hybrid C++ / Python Plugins</a></li><li><a href=/deploy/developers/clang_syntax/></a></li></ul></li><li class=has-sub-menu><a href=/deploy/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/getting_started/Faq/>Frequently Asked Questions</a></li><li><a href=/deploy/getting_started/build_from_source/>Build Everything from Source</a></li></ul></li><li class="parent has-sub-menu"><a href=/deploy/lang_spec/>QCOR Classical Language Extension<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/deploy/lang_spec/data_model/>Data Model</a></li><li><a href=/deploy/lang_spec/exec_model/>Execution Model</a></li><li><a href=/deploy/lang_spec/memory/>Memory Model</a></li><li class=active><a href=/deploy/lang_spec/prog_model/>Programming Model</a></li></ul></li><li class=has-sub-menu><a href=/deploy/users/>User Guide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/users/hello_world/>Hello World</a></li><li><a href=/deploy/users/operators/>Operators</a></li><li><a href=/deploy/users/pass_manager/>Pass Manager</a></li><li><a href=/deploy/users/qjit/>Quantum JIT (QJIT)</a></li><li><a href=/deploy/users/quantum_kernels/>Quantum Kernels</a></li><li><a href=/deploy/users/quasimo/>Quantum Simulation Modeling (QuaSiMo)</a></li><li><a href=/deploy/users/remote_qpu_creds/>Remote QPU Credentials</a></li><li><a href=/deploy/users/tnqvm/>Tensor Network Quantum Virtual Machine</a></li><li><a href=/deploy/users/using_optimizer/>Using an Optimizer</a></li><li><a href=/deploy/users/variational/>Variational Algorithms</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>